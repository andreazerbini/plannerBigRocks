<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kanban Covey – Tabs + Tabelle + Drive</title>
    <style>
      :root {
        --bg: #0b0f16;
        --panel: #121826;
        --muted: #9aa4b2;
        --text: #e6edf3;
        --accent: #5eead4;
        --card: #0f172a;
        --border: #263046;
        --warn: #f59e0b;
        --danger: #ef4444;
        --h-header: 56px;
        --h-tabs: 46px;
        --sticky-top: calc(var(--h-header) + var(--h-tabs));
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        color: var(--text);
        background: linear-gradient(120deg, #0b0f16, #0a1322 60%, #0b0f16);
      }

      header {
        position: sticky;
        top: 0;
        z-index: 20;
        display: flex;
        align-items: center;
        gap: 0.8rem;
        height: var(--h-header);
        padding: 1rem;
        border-bottom: 1px solid var(--border);
        background: rgba(11, 15, 22, 0.7);
        backdrop-filter: blur(8px);
      }

      h1 {
        margin: 0;
        font-size: 1.05rem;
        font-weight: 700;
        letter-spacing: 0.2px;
      }

      .tag {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 999px;
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-left: auto;
      }

      .sprint-strip-wrapper {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 0.5rem 0;
      }

      .sprint-strip {
        display: flex;
        align-items: stretch;
        justify-content: center;
        gap: 0.5rem;
      }

      .sprint-nav {
        width: 40px;
        height: 40px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: var(--panel);
        color: var(--muted);
        font-size: 1.1rem;
        cursor: pointer;
        transition: border-color 0.2s ease, color 0.2s ease;
      }

      .sprint-nav:hover:not(:disabled) {
        border-color: #33405e;
        color: var(--text);
      }

      .sprint-nav:disabled {
        opacity: 0.35;
        cursor: default;
      }

      .sprint-pill {
        min-width: 160px;
        padding: 0.5rem 0.75rem;
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        background: rgba(18, 24, 38, 0.7);
        color: var(--muted);
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
        transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease,
          box-shadow 0.2s ease;
        white-space: nowrap;
      }

      .sprint-pill .sprint-name {
        font-weight: 600;
        font-size: 0.85rem;
      }

      .sprint-pill .sprint-dates {
        font-size: 0.75rem;
        color: var(--muted);
        opacity: 0.8;
      }

      .sprint-pill.current {
        border-color: rgba(94, 234, 212, 0.75);
        background: linear-gradient(135deg, rgba(94, 234, 212, 0.25), rgba(14, 116, 144, 0.2));
        color: #e6fffb;
        box-shadow: 0 0 0 1px rgba(94, 234, 212, 0.2);
      }

      .sprint-pill.current .sprint-dates {
        color: #ccfbf1;
      }

      .sprint-pill.selected {
        border-color: #38bdf8;
        box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.35);
      }

      .sprint-pill.selected:not(.current) {
        background: linear-gradient(135deg, rgba(18, 24, 38, 0.95), rgba(30, 41, 59, 0.95));
        color: var(--text);
      }

      .sprint-pill.current.selected {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(94, 234, 212, 0.45);
      }

      button,
      input,
      select,
      textarea {
        font: inherit;
      }

      button {
        padding: 0.55rem 0.75rem;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        background: var(--panel);
        cursor: pointer;
      }

      button:hover {
        border-color: #33405e;
      }

      button.primary {
        color: #061317;
        border-color: transparent;
        background: linear-gradient(135deg, #12b3a6, #6ee7d2);
      }

      button.primary:hover {
        filter: brightness(1.02);
      }

      button.danger {
        color: #2b100f;
        border-color: transparent;
        background: linear-gradient(135deg, #ef4444, #f59e0b);
      }

      nav.tabs {
        position: sticky;
        top: var(--h-header);
        z-index: 15;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        height: var(--h-tabs);
        padding: 0.6rem 1rem;
        border-bottom: 1px solid var(--border);
        background: rgba(11, 15, 22, 0.7);
        backdrop-filter: blur(8px);
      }

      .tab {
        padding: 0.45rem 0.75rem;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 0.65rem;
        cursor: pointer;
        background: transparent;
      }

      .tab.active {
        color: #061317;
        border-color: transparent;
        background: linear-gradient(135deg, #12b3a6, #6ee7d2);
      }

      main {
        display: grid;
        gap: 1rem;
        padding: 1rem;
      }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        background: rgba(18, 24, 38, 0.7);
        border: 1px solid var(--border);
        border-radius: 0.9rem;
        overflow: hidden;
      }

      thead th {
        /* position: sticky; */
        top: var(--sticky-top);
        z-index: 10;
        padding: 0.7rem 0.8rem;
        font-size: 0.85rem;
        text-align: left;
        white-space: nowrap;
        color: var(--muted);
        user-select: none;
        background: #121826;
        border-bottom: 1px solid var(--border);
      }

      th.sortable {
        cursor: pointer;
      }

      th.sortable::after {
        margin-left: 0.25rem;
        font-size: 0.7rem;
        opacity: 0.35;
        content: "▲▼";
      }

      th.sortable.asc::after {
        content: "▲";
        opacity: 0.85;
      }

      th.sortable.desc::after {
        content: "▼";
        opacity: 0.85;
      }

      tbody td {
        padding: 0.6rem 0.8rem;
        border-bottom: 1px solid #1b2436;
      }

      tbody tr:hover {
        background: #0f1628;
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .controls.filters {
        align-items: flex-end;
        gap: 0.75rem;
      }

      .filter-field {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        min-width: 140px;
        font-size: 0.75rem;
        color: var(--muted);
      }

      .filter-field input,
      .filter-field select {
        width: 100%;
      }

      input[type="text"],
      input[type="number"],
      input[type="date"],
      select,
      textarea {
        width: 100%;
        padding: 0.45rem 0.5rem;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        background: #0b1324;
      }

      textarea {
        min-height: 54px;
        resize: vertical;
      }

      .kanban {
        display: grid;
        grid-auto-flow: column;
        grid-auto-columns: minmax(260px, 1fr);
        gap: 1rem;
        overflow-x: auto;
        padding-bottom: 0.5rem;
      }

      .kanban-column {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 200px;
        padding: 0.9rem;
        border: 1px solid var(--border);
        border-radius: 0.9rem;
        background: rgba(18, 24, 38, 0.7);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .kanban-column.dragover {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px var(--accent);
      }

      .kanban-column-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        font-weight: 600;
      }

      .kanban-column-count {
        font-size: 0.8rem;
        color: var(--muted);
      }

      .kanban-column-body {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 48px;
      }

      .kanban-column-placeholder {
        margin: 0;
        padding: 1rem;
        font-size: 0.85rem;
        color: var(--muted);
        text-align: center;
        border: 1px dashed var(--border);
        border-radius: 0.8rem;
      }

      .kanban-card {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        padding: 0.8rem;
        border: 1px solid var(--border);
        border-radius: 0.85rem;
        background: var(--card);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        cursor: grab;
      }

      .kanban-card.dragging {
        opacity: 0.6;
      }

      .kanban-card:active {
        cursor: grabbing;
      }

      .kanban-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
      }

      .kanban-card-hierarchy {
        font-size: 0.75rem;
        color: var(--muted);
      }

      .kanban-card-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
      }

      .kanban-card .description {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .badge {
        display: inline-block;
        padding: 0.1rem 0.45rem;
        font-size: 0.7rem;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
      }

      .title {
        font-weight: 700;
      }

      .task-state-select {
        --state-color: var(--border);
        border: 2px solid var(--state-color);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .task-state-select:focus {
        box-shadow: 0 0 0 2px rgba(94, 234, 212, 0.35);
      }

      .footer {
        padding: 1rem;
        font-size: 0.85rem;
        color: var(--muted);
        border-top: 1px solid var(--border);
      }

      @media (max-width: 700px) {
        header {
          align-items: flex-start;
        }

        .kanban {
          grid-auto-columns: minmax(220px, 1fr);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Kanban Covey</h1>
      <span class="tag">Ruoli → LT → BT → Attività</span>
      <div class="actions">
        <button id="export">Esporta JSON</button>
        <button id="importBtn">Importa JSON</button>
        <button id="saveFile">Salva su file</button>
        <button id="openFile">Apri file</button>
        <button id="gSignIn">Connetti Google</button>
        <button id="driveOpen" disabled>Apri da Drive</button>
        <button id="driveSave" disabled>Salva su Drive</button>
        <span id="driveStatus" class="tag" title="Stato Google Drive">Drive: offline</span>
        <button class="danger" id="clear">Azzera</button>
      </div>
    </header>

    <nav id="tabs" class="tabs"></nav>
    <main id="view"></main>

    <footer class="footer">
      <strong>Salvataggio locale:</strong> automatico in <code>localStorage</code>.
      Puoi anche <em>Esportare/Importare</em> JSON.
      Su browser Chromium/Edge puoi usare "Salva su file" e "Apri file" (File System Access API).
      <br />
      Opzionale: connessione a <strong>Google Drive</strong> (inserisci <em>Client ID</em> e <em>API Key</em>) per aprire/salvare il JSON.
    </footer>

    <input id="filePicker" type="file" accept="application/json" hidden />
    <input
      id="taskCsvPicker"
      type="file"
      accept="text/csv,.csv"
      hidden
    />

    <script>
      (() => {
        "use strict";

        // =============================================================
        // Costanti e configurazione di base
        // =============================================================
        const STORAGE_KEYS = Object.freeze({
          STATE: "covey_v2_domain_model",
          GD_CLIENT_ID: "covey_gd_client_id",
          GD_API_KEY: "covey_gd_api_key",
          GD_FOLDER_ID: "covey_gd_folder_id",
        });

        const DRIVE_FOLDER_NAME = "Kanban_Covey_BigRocks";
        const DRIVE_FILE_PREFIX = "kanban_covey_bigrocks";

        const DEFAULT_FILE_NAME = "kanban-covey.json";
        const GOOGLE_DISCOVERY_DOCS = [
          "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest",
        ];
        const GOOGLE_SCOPE = "https://www.googleapis.com/auth/drive.file";

        const TASK_STATE_IDS = Object.freeze({
          TO_REFINE: "to_refine",
          TO_DO: "to_do",
          IN_PROGRESS: "in_progress",
          PAUSED: "paused",
          DONE: "done",
          REJECTED: "rejected",
        });

        const TASK_STATES = [
          {
            id: TASK_STATE_IDS.TO_REFINE,
            label: "Da pensare meglio",
            color: "#9ca3af",
          },
          {
            id: TASK_STATE_IDS.TO_DO,
            label: "Da fare",
            color: "#38bdf8",
          },
          {
            id: TASK_STATE_IDS.IN_PROGRESS,
            label: "In evoluzione",
            color: "#facc15",
          },
          {
            id: TASK_STATE_IDS.PAUSED,
            label: "Paused",
            color: "#f97316",
          },
          {
            id: TASK_STATE_IDS.DONE,
            label: "Fatto",
            color: "#22c55e",
          },
          {
            id: TASK_STATE_IDS.REJECTED,
            label: "Rejected",
            color: "#ef4444",
          },
        ];

        const CLOSING_TASK_STATES = new Set([
          TASK_STATE_IDS.DONE,
          TASK_STATE_IDS.REJECTED,
        ]);

        function isoToday() {
          return new Date().toISOString().slice(0, 10);
        }

        function isoAddDays(days, fromDate) {
          const base = fromDate ? new Date(fromDate) : new Date();
          if (Number.isFinite(days)) {
            base.setDate(base.getDate() + Number(days));
          }
          return base.toISOString().slice(0, 10);
        }

        function sanitizeIsoDate(value) {
          const trimmed = typeof value === "string" ? value.trim() : "";
          return /^\d{4}-\d{2}-\d{2}$/.test(trimmed) ? trimmed : null;
        }

        function promptForIsoDate(message, initialValue) {
          const defaultValue = sanitizeIsoDate(initialValue) || isoToday();
          const response = window.prompt(message, defaultValue);
          if (response == null) return null;
          const trimmed = response.trim();
          if (!trimmed) return "";
          if (!/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
            alert("Formato data non valido. Usa YYYY-MM-DD.");
            return promptForIsoDate(message, defaultValue);
          }
          return trimmed;
        }

        const DEFAULT_TASK_STATE = TASK_STATE_IDS.TO_DO;
        const TASK_STATE_BY_ID = new Map(
          TASK_STATES.map((state) => [state.id, state])
        );

        const tabs = [
          { id: "roles", label: "Ruoli" },
          { id: "lt", label: "Obiettivi a lungo termine" },
          { id: "st", label: "Obiettivi a breve termine" },
          { id: "tasks", label: "Attività" },
          { id: "dash", label: "Dashboard" },
        ];

        // =============================================================
        // Stato applicativo e persistence layer
        // =============================================================
        const AppState = {
          data: loadState(),
          currentFileHandle: null,
          persist() {
            localStorage.setItem(
              STORAGE_KEYS.STATE,
              JSON.stringify(this.data)
            );
          },
          replace(nextState) {
            normalizeDomain(nextState);
            this.data = nextState;
            updateSelectedSprint(
              this.data.currentSprintId || selectedSprintId,
              { rerenderShortTerm: false }
            );
            this.persist();
          },
          nextId() {
            return String(this.data.nextId++);
          },
        };

        function defaultState() {
          return { nextId: 1, roles: [], sprints: [], currentSprintId: null };
        }

        function loadState() {
          try {
            const raw = localStorage.getItem(STORAGE_KEYS.STATE);
            if (!raw) return seedState();
            const parsed = JSON.parse(raw);
            if (!validate(parsed)) return seedState();
            normalizeDomain(parsed);
            return parsed;
          } catch (err) {
            console.warn("Impossibile leggere lo stato salvato, uso seed.", err);
            return seedState();
          }
        }

        function seedState() {
          const seeded = defaultState();
          const today = () => new Date().toISOString().slice(0, 10);
          const datePlus = (days) => {
            const date = new Date();
            date.setDate(date.getDate() + days);
            return date.toISOString().slice(0, 10);
          };
          const nextId = () => String(seeded.nextId++);

          const sprint = {
            id: nextId(),
            name: "Sprint iniziale",
            start: today(),
            end: datePlus(14),
            st_goal_ids: [],
          };

          const role = {
            id: nextId(),
            title: "Team Leader",
            importance: 3,
            lt_goals: [],
          };
          const longTerm = {
            id: nextId(),
            title: "Introdurre ML nel prodotto",
            description: "Roadmap ML (RAG, valutazione, privacy)",
            importance: 5,
            due: datePlus(120),
            achieved_on: null,
            st_goals: [],
          };
          const shortTerm = {
            id: nextId(),
            title: "PoC RAG su documentale",
            description: "Pipeline base eval + feedback",
            importance: null,
            due: null,
            achieved_on: null,
            sprint_id: sprint.id,
            tasks: [],
          };
          const task = {
            id: nextId(),
            title: "Progettazione schema vector DB",
            description: "Definire spazio embedding e chunking",
            importance: 4,
            due: datePlus(30),
            state: TASK_STATE_IDS.TO_DO,
            closed_on: null,
          };

          shortTerm.tasks.push(task);
          longTerm.st_goals.push(shortTerm);
          role.lt_goals.push(longTerm);
          sprint.st_goal_ids.push(shortTerm.id);
          seeded.roles.push(role);
          seeded.sprints.push(sprint);
          seeded.currentSprintId = sprint.id;
          normalizeDomain(seeded);
          return seeded;
        }

        function validate(candidate) {
          return (
            candidate &&
            typeof candidate === "object" &&
            Array.isArray(candidate.roles) &&
            "nextId" in candidate
          );
        }

        function getTaskStateId(stateId) {
          return TASK_STATE_BY_ID.has(stateId) ? stateId : DEFAULT_TASK_STATE;
        }

        function getTaskStateConfig(stateId) {
          return TASK_STATE_BY_ID.get(getTaskStateId(stateId));
        }

        function normalizeTask(task) {
          if (!task || typeof task !== "object") return;
          task.state = getTaskStateId(task.state);
          task.closed_on = sanitizeIsoDate(task.closed_on);
        }

        function normalizeDomain(root) {
          if (!root || typeof root !== "object") return;

          const numericNextId = Number(root.nextId);
          root.nextId = Number.isFinite(numericNextId) ? numericNextId : 1;
          const allocateId = () => String(root.nextId++);

          if (!Array.isArray(root.roles)) {
            root.roles = [];
          }
          if (!Array.isArray(root.sprints)) {
            root.sprints = [];
          }

          const sprintById = new Map();
          root.sprints = root.sprints.map((sprint, index) => {
            const id = sprint?.id != null ? String(sprint.id) : allocateId();
            const normalized = {
              id,
              name: sprint?.name || `Sprint ${index + 1}`,
              start: sanitizeIsoDate(sprint?.start),
              end: sanitizeIsoDate(sprint?.end),
              st_goal_ids: Array.isArray(sprint?.st_goal_ids)
                ? sprint.st_goal_ids.map((value) => String(value))
                : [],
            };
            sprintById.set(id, normalized);
            return normalized;
          });

          if (!root.sprints.length) {
            const id = allocateId();
            const defaultSprint = {
              id,
              name: "Sprint iniziale",
              start: isoToday(),
              end: isoAddDays(14),
              st_goal_ids: [],
            };
            root.sprints.push(defaultSprint);
            sprintById.set(id, defaultSprint);
          }

          if (root.currentSprintId != null) {
            root.currentSprintId = String(root.currentSprintId);
          }
          if (!root.currentSprintId || !sprintById.has(root.currentSprintId)) {
            root.currentSprintId = root.sprints[0]?.id || null;
          }

          const existingShortTerms = new Set();

          root.roles.forEach((role) => {
            role.id = role?.id != null ? String(role.id) : allocateId();
            role.lt_goals = Array.isArray(role.lt_goals) ? role.lt_goals : [];
            role.lt_goals.forEach((lt) => {
              lt.id = lt?.id != null ? String(lt.id) : allocateId();
              lt.st_goals = Array.isArray(lt.st_goals) ? lt.st_goals : [];
              lt.achieved_on = sanitizeIsoDate(lt.achieved_on);
              lt.st_goals.forEach((st) => {
                st.id = st?.id != null ? String(st.id) : allocateId();
                st.tasks = Array.isArray(st.tasks) ? st.tasks : [];
                st.achieved_on = sanitizeIsoDate(st.achieved_on);
                if (st.sprint_id != null) {
                  st.sprint_id = String(st.sprint_id);
                }
                if (!st.sprint_id || !sprintById.has(st.sprint_id)) {
                  st.sprint_id = root.currentSprintId;
                }
                if (st.sprint_id && sprintById.has(st.sprint_id)) {
                  const sprint = sprintById.get(st.sprint_id);
                  if (!Array.isArray(sprint.st_goal_ids)) {
                    sprint.st_goal_ids = [];
                  }
                  if (!sprint.st_goal_ids.includes(st.id)) {
                    sprint.st_goal_ids.push(st.id);
                  }
                }
                existingShortTerms.add(st.id);
                st.tasks.forEach(normalizeTask);
              });
            });
          });

          root.sprints.forEach((sprint) => {
            if (!Array.isArray(sprint.st_goal_ids)) {
              sprint.st_goal_ids = [];
            }
            const unique = [];
            const seen = new Set();
            sprint.st_goal_ids
              .map((value) => String(value))
              .forEach((id) => {
                if (!existingShortTerms.has(id)) return;
                if (seen.has(id)) return;
                seen.add(id);
                unique.push(id);
              });
            sprint.st_goal_ids = unique;
          });
        }

        function findTaskRef({ roleId, ltId, stId, taskId }) {
          const role = AppState.data.roles.find((candidate) => candidate.id === roleId);
          if (!role) return null;
          const lt = role.lt_goals.find((candidate) => candidate.id === ltId);
          if (!lt) return null;
          const st = lt.st_goals.find((candidate) => candidate.id === stId);
          if (!st) return null;
          const task = st.tasks.find((candidate) => candidate.id === taskId);
          if (!task) return null;
          return { role, lt, st, task };
        }

        // =============================================================
        // Utilità di formattazione e coercizione
        // =============================================================
        const DateUtils = {
          today: () => new Date().toISOString().slice(0, 10),
          addDays(days) {
            const date = new Date();
            date.setDate(date.getDate() + days);
            return date.toISOString().slice(0, 10);
          },
        };

          function toImportance(value, fallback = 1) {
              const parsed = parseInt(value, 10);
              if (Number.isNaN(parsed)) return fallback;
              return Math.max(1, parsed); // ← niente limite superiore
          }

        function toImportanceOrNull(value) {
          if (value == null || value === "") return null;
          return toImportance(value, 1);
        }

        function formatSprintRange(sprint) {
          if (!sprint) return "—";
          const start = sprint.start || "—";
          const end = sprint.end || "—";
          return `${start} → ${end}`;
        }

        function ensureCurrentSprintId() {
          if (!Array.isArray(AppState.data.sprints)) {
            AppState.data.sprints = [];
          }
          let created = false;
          if (!AppState.data.sprints.length) {
            const newSprint = createSprint(
              `Sprint ${AppState.data.sprints.length + 1}`,
              DateUtils.today(),
              DateUtils.addDays(14)
            );
            AppState.data.sprints.push(newSprint);
            AppState.data.currentSprintId = newSprint.id;
            created = true;
          }
          if (
            !AppState.data.currentSprintId ||
            !AppState.data.sprints.some(
              (sprint) => sprint.id === AppState.data.currentSprintId
            )
          ) {
            AppState.data.currentSprintId =
              AppState.data.sprints[0]?.id || null;
            created = true;
          }
          return { id: AppState.data.currentSprintId, created };
        }

        function detachShortTermFromSprint(shortTerm) {
          if (!shortTerm || !shortTerm.sprint_id) return;
          const sprints = AppState.data.sprints || [];
          const sprint = sprints.find(
            (candidate) => candidate.id === shortTerm.sprint_id
          );
          if (sprint && Array.isArray(sprint.st_goal_ids)) {
            sprint.st_goal_ids = sprint.st_goal_ids.filter(
              (id) => id !== shortTerm.id
            );
          }
          shortTerm.sprint_id = null;
        }

        function attachShortTermToSprint(shortTerm, sprintId) {
          if (!shortTerm) return;
          const normalizedId = sprintId != null ? String(sprintId) : null;
          if (!normalizedId) {
            detachShortTermFromSprint(shortTerm);
            return;
          }
          if (shortTerm.sprint_id && shortTerm.sprint_id !== normalizedId) {
            detachShortTermFromSprint(shortTerm);
          }
          const sprint = (AppState.data.sprints || []).find(
            (candidate) => candidate.id === normalizedId
          );
          if (!sprint) return;
          shortTerm.sprint_id = normalizedId;
          if (!Array.isArray(sprint.st_goal_ids)) {
            sprint.st_goal_ids = [];
          }
          if (!sprint.st_goal_ids.includes(shortTerm.id)) {
            sprint.st_goal_ids.push(shortTerm.id);
          }
        }

        function applyTaskStateChange(task, nextStateId) {
          if (!task) return false;
          const previousState = getTaskStateId(task.state);
          const normalizedNext = getTaskStateId(nextStateId);
          if (previousState === normalizedNext) return true;

          if (CLOSING_TASK_STATES.has(normalizedNext)) {
            const value = promptForIsoDate(
              "Data effettiva di chiusura (YYYY-MM-DD)",
              task.closed_on || isoToday()
            );
            if (value === null) {
              return false;
            }
            task.closed_on = value ? value : null;
          } else if (CLOSING_TASK_STATES.has(previousState)) {
            task.closed_on = null;
          }

          task.state = normalizedNext;
          normalizeTask(task);
          return true;
        }

        // =============================================================
        // Ereditarietà di importanza/scadenza
        // =============================================================
        function effectiveImportance(node, parentImportance) {
          return node.importance != null
            ? toImportance(node.importance, 1)
            : parentImportance;
        }

        function effectiveDueDate(node, parentDueDate) {
          return node.due || parentDueDate || null;
        }

        function clampChildToParent(child, parent) {
          const parentImportance = effectiveImportance(parent, 9999999);
          const parentDue = parent.due || null;

          if (
            child.importance != null &&
            child.importance > parentImportance
          ) {
            child.importance = parentImportance;
          }

          if (parentDue && child.due && child.due > parentDue) {
            child.due = parentDue;
          }
        }

          function cascadeFromRole(role) {
              role.lt_goals.forEach((lt) => {
                  // LT non può superare il Ruolo
                  clampChildToParent(lt, role);

                  lt.st_goals.forEach((st) => {
                      clampChildToParent(st, lt);
                      st.tasks.forEach((task) =>
                          clampChildToParent(task, st.due ? st : lt)
                      );
                  });
              });
          }


        // =============================================================
        // UI references e gestione tab
        // =============================================================
        const dom = {
          tabs: document.getElementById("tabs"),
          view: document.getElementById("view"),
          filePicker: document.getElementById("filePicker"),
          taskCsvPicker: document.getElementById("taskCsvPicker"),
          exportBtn: document.getElementById("export"),
          importBtn: document.getElementById("importBtn"),
          saveFileBtn: document.getElementById("saveFile"),
          openFileBtn: document.getElementById("openFile"),
          clearBtn: document.getElementById("clear"),
          driveStatus: document.getElementById("driveStatus"),
          googleBtn: document.getElementById("gSignIn"),
          driveOpenBtn: document.getElementById("driveOpen"),
          driveSaveBtn: document.getElementById("driveSave"),
        };

        function requestTaskCsvImport() {
          if (!dom.taskCsvPicker) return;
          dom.taskCsvPicker.value = "";
          dom.taskCsvPicker.click();
        }

        dom.taskCsvPicker?.addEventListener("change", async (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          try {
            const text = await file.text();
            const imported = importTasksFromCsvContent(text);
            AppState.persist();
            render();
            alert(`Importate ${imported} attività da CSV ✅`);
          } catch (error) {
            alert(`Errore import CSV: ${error.message || error}`);
          } finally {
            dom.taskCsvPicker.value = "";
          }
        });

        let activeTab = "roles";
        let selectedSprintId = AppState.data.currentSprintId || null;

        function updateSelectedSprint(
          nextId,
          { rerenderShortTerm = false } = {}
        ) {
          const normalized = nextId != null ? String(nextId) : null;
          if (normalized === selectedSprintId) {
            if (rerenderShortTerm) {
              render();
            }
            return;
          }
          selectedSprintId = normalized;
          rerenderTaskView();
          if (rerenderShortTerm) {
            render();
          }
        }

        function render() {
          renderTabs();
          const renderer = tabRenderers[activeTab];
          if (renderer) renderer();
        }

        function renderTabs() {
          dom.tabs.innerHTML = "";
          tabs.forEach((tab) => {
            const element = document.createElement("button");
            element.className = `tab${activeTab === tab.id ? " active" : ""}`;
            element.textContent = tab.label;
            element.addEventListener("click", () => {
              activeTab = tab.id;
              render();
            });
            dom.tabs.appendChild(element);
          });
        }

        const tabRenderers = {
          roles: renderRoles,
          lt: renderLongTermGoals,
          st: renderShortTermGoals,
          tasks: renderTasks,
          dash: renderDashboard,
        };

        // =============================================================
        // Helper UI element factories
        // =============================================================
        function inputText(value, placeholder, onInput) {
          const input = document.createElement("input");
          input.type = "text";
          input.value = value || "";
          if (placeholder) input.placeholder = placeholder;
          if (onInput) {
            input.addEventListener("input", () => onInput(input.value));
          }
          return input;
        }

        function inputInteger(value, onInput) {
          const input = document.createElement("input");
          input.type = "number";
          input.min = "1";
          // input.max = "99999";
          input.step = "1";
          input.value = value ?? "";
          input.addEventListener("input", () => {
            onInput(input.value === "" ? null : toImportance(input.value));
          });
          return input;
        }

          function inputDate(value, onInput, { readOnly = false } = {}) {
              const input = document.createElement("input");
              input.type = "date";
              input.value = value || "";

              // Solo se esplicitamente richiesto, blocca la digitazione
              if (readOnly) {
                  input.readOnly = true;
                  input.addEventListener("keydown", (e) => e.preventDefault());
              }

              // Apri il calendario automaticamente al focus
              input.addEventListener("focus", () => {
                  // Questo funziona sulla maggior parte dei browser moderni
                  try {
                      input.showPicker?.();
                  } catch (e) {
                      // Fallback silenzioso se non supportato
                  }
              });

              // Aggiorna lo stato quando cambia la data
              input.addEventListener("change", () => {
                  onInput(input.value || null);
              });

              // Anche su input per catturare la digitazione
              input.addEventListener("input", () => {
                  onInput(input.value || null);
              });

              return input;
          }

        function textArea(value, onInput) {
          const area = document.createElement("textarea");
          area.value = value || "";
          area.addEventListener("input", () => onInput(area.value));
          return area;
        }

        function button(label, className, onClick) {
          const btn = document.createElement("button");
          btn.textContent = label;
          if (className) btn.className = className;
          btn.addEventListener("click", onClick);
          return btn;
        }

        function labeledControl(labelText, control) {
          const wrapper = document.createElement("label");
          wrapper.style.display = "flex";
          wrapper.style.flexDirection = "column";
          wrapper.style.gap = "0.25rem";
          const caption = document.createElement("span");
          caption.textContent = labelText;
          caption.style.fontSize = "0.75rem";
          caption.style.color = "var(--muted)";
          wrapper.append(caption, control);
          return wrapper;
        }

        const TASK_CSV_FILE_NAME = "kanban-covey-tasks.csv";
        const TASK_CSV_HEADERS = Object.freeze([
          "Ruolo",
          "LT",
          "ST",
          "Titolo",
          "Descrizione",
          "Importanza",
          "Scadenza",
          "Stato",
        ]);

        const TASK_CSV_COLUMN_ALIASES = Object.freeze({
          role: ["ruolo", "role"],
          lt: ["lt", "obiettivo lt", "lungo termine", "long term", "long-term"],
          st: [
            "st",
            "bt",
            "obiettivo bt",
            "breve termine",
            "short term",
            "short-term",
          ],
          title: ["titolo", "title"],
          description: ["descrizione", "description"],
          importance: ["importanza", "importance"],
          due: ["scadenza", "due", "deadline", "data"],
          state: ["stato", "state"],
        });

        const TASK_CSV_COLUMN_LABELS = Object.freeze({
          role: "Ruolo",
          lt: "LT",
          st: "ST",
          title: "Titolo",
          description: "Descrizione",
          importance: "Importanza",
          due: "Scadenza",
          state: "Stato",
        });

        const TaskFilters = {
          roleId: null,
          ltId: null,
          stId: null,
          importanceMin: null,
          importanceMax: null,
          dueFrom: null,
          dueTo: null,
          state: "all",
          search: "",
        };
        let taskSearchDraft = TaskFilters.search;

        function getAllTaskRefs() {
          const refs = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) =>
              lt.st_goals.forEach((st) =>
                st.tasks.forEach((task) => refs.push({ role, lt, st, task }))
              )
            )
          );
          return refs;
        }

        function getFilteredTaskRefs() {
          return getAllTaskRefs().filter(taskMatchesFilters);
        }

        function taskMatchesFilters(ref) {
          const sprintFilter =
            selectedSprintId || AppState.data.currentSprintId || null;
          if (sprintFilter && ref.st.sprint_id !== sprintFilter) {
            return false;
          }

          const {
            roleId,
            ltId,
            stId,
            importanceMin,
            importanceMax,
            dueFrom,
            dueTo,
            state,
            search,
          } = TaskFilters;
          if (roleId && ref.role.id !== roleId) {
            return false;
          }

          if (ltId && ref.lt.id !== ltId) {
            return false;
          }

          if (stId && ref.st.id !== stId) {
            return false;
          }
          const taskImportance =
            ref.task.importance != null
              ? toImportance(ref.task.importance, 1)
              : null;

          if (importanceMin != null) {
            if (taskImportance == null || taskImportance < importanceMin) {
              return false;
            }
          }

          if (importanceMax != null) {
            if (taskImportance == null || taskImportance > importanceMax) {
              return false;
            }
          }

          const taskState = ref.task.state || DEFAULT_TASK_STATE;
          if (state !== "all" && taskState !== state) {
            return false;
          }

          const dueTimestamp = parseDateToTimestamp(ref.task.due);
          const fromTimestamp = parseDateToTimestamp(dueFrom);
          if (fromTimestamp != null) {
            if (dueTimestamp == null || dueTimestamp < fromTimestamp) {
              return false;
            }
          }

          const toTimestamp = parseDateToTimestamp(dueTo);
          if (toTimestamp != null) {
            if (dueTimestamp == null || dueTimestamp > toTimestamp) {
              return false;
            }
          }

          const query = normalizeForComparison(search);
          if (query) {
            const haystack = normalizeForComparison(
              `${ref.task.title || ""} ${ref.task.description || ""}`
            );
            if (!haystack.includes(query)) {
              return false;
            }
          }

          return true;
        }

        function parseDateToTimestamp(value) {
          if (!value) return null;
          const parsed = Date.parse(`${value}T00:00:00Z`);
          return Number.isNaN(parsed) ? null : parsed;
        }

        function updateTaskFilters(patch) {
          let changed = false;
          Object.entries(patch).forEach(([key, value]) => {
            if (TaskFilters[key] !== value) {
              TaskFilters[key] = value;
              changed = true;
            }
          });
          if (!changed) return;
          if (Object.prototype.hasOwnProperty.call(patch, "search")) {
            taskSearchDraft = TaskFilters.search;
          }
          rerenderTaskView();
        }

        function rerenderTaskView() {
          if (activeTab === "tasks") {
            renderTasks();
          } else if (activeTab === "dash") {
            renderDashboard();
          }
        }

        function createTaskFiltersBar({ onExport, onImport }) {
          const container = document.createElement("div");
          container.className = "controls filters";

          const roleSelect = document.createElement("select");
          {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "Tutti i ruoli";
            roleSelect.appendChild(option);
          }
          AppState.data.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = role.title || "—";
            roleSelect.appendChild(option);
          });
          roleSelect.value = TaskFilters.roleId || "";
          roleSelect.addEventListener("change", () => {
            const selectedRoleId = roleSelect.value || null;
            const patch = { roleId: selectedRoleId };
            if (TaskFilters.roleId !== selectedRoleId) {
              patch.ltId = null;
              patch.stId = null;
            }
            updateTaskFilters(patch);
          });

          const ltSelect = document.createElement("select");
          const stSelect = document.createElement("select");
          const ltMetaById = new Map();
          const stMetaById = new Map();

          function populateLtOptions() {
            ltMetaById.clear();
            ltSelect.innerHTML = "";
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "Tutti i LT";
            ltSelect.appendChild(option);
            AppState.data.roles.forEach((role) => {
              if (TaskFilters.roleId && role.id !== TaskFilters.roleId) return;
              role.lt_goals.forEach((lt) => {
                ltMetaById.set(lt.id, { roleId: role.id });
                const ltOption = document.createElement("option");
                ltOption.value = lt.id;
                ltOption.textContent = `${role.title || "—"} › ${lt.title || "—"}`;
                ltSelect.appendChild(ltOption);
              });
            });
            const selectedLt = TaskFilters.ltId;
            if (selectedLt && ltMetaById.has(selectedLt)) {
              ltSelect.value = selectedLt;
            } else {
              ltSelect.value = "";
            }
          }

          function populateStOptions() {
            stMetaById.clear();
            stSelect.innerHTML = "";
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "Tutti i BT";
            stSelect.appendChild(option);
            AppState.data.roles.forEach((role) => {
              if (TaskFilters.roleId && role.id !== TaskFilters.roleId) return;
              role.lt_goals.forEach((lt) => {
                if (TaskFilters.ltId && lt.id !== TaskFilters.ltId) return;
                lt.st_goals.forEach((st) => {
                  stMetaById.set(st.id, { roleId: role.id, ltId: lt.id });
                  const stOption = document.createElement("option");
                  stOption.value = st.id;
                  stOption.textContent = `${role.title || "—"} › ${lt.title || "—"} › ${
                    st.title || "—"
                  }`;
                  stSelect.appendChild(stOption);
                });
              });
            });
            const selectedSt = TaskFilters.stId;
            if (selectedSt && stMetaById.has(selectedSt)) {
              stSelect.value = selectedSt;
            } else {
              stSelect.value = "";
            }
          }

          populateLtOptions();
          populateStOptions();

          ltSelect.addEventListener("change", () => {
            const value = ltSelect.value || null;
            if (!value) {
              updateTaskFilters({ ltId: null, stId: null });
              return;
            }
            const meta = ltMetaById.get(value);
            const patch = { ltId: value, stId: null };
            if (meta && TaskFilters.roleId !== meta.roleId) {
              patch.roleId = meta.roleId;
            }
            updateTaskFilters(patch);
          });

          stSelect.addEventListener("change", () => {
            const value = stSelect.value || null;
            if (!value) {
              updateTaskFilters({ stId: null });
              return;
            }
            const meta = stMetaById.get(value);
            const patch = { stId: value };
            if (meta) {
              if (TaskFilters.ltId !== meta.ltId) {
                patch.ltId = meta.ltId;
              }
              if (TaskFilters.roleId !== meta.roleId) {
                patch.roleId = meta.roleId;
              }
            }
            updateTaskFilters(patch);
          });

          const importanceMinInput = document.createElement("input");
          importanceMinInput.type = "number";
          importanceMinInput.min = "1";
          importanceMinInput.placeholder = "≥";
          importanceMinInput.value =
            TaskFilters.importanceMin != null ? TaskFilters.importanceMin : "";
          importanceMinInput.addEventListener("change", () => {
            const value = importanceMinInput.value.trim();
            updateTaskFilters({
              importanceMin: value === "" ? null : toImportance(value, 1),
            });
          });

          const importanceMaxInput = document.createElement("input");
          importanceMaxInput.type = "number";
          importanceMaxInput.min = "1";
          importanceMaxInput.placeholder = "≤";
          importanceMaxInput.value =
            TaskFilters.importanceMax != null ? TaskFilters.importanceMax : "";
          importanceMaxInput.addEventListener("change", () => {
            const value = importanceMaxInput.value.trim();
            updateTaskFilters({
              importanceMax: value === "" ? null : toImportance(value, 1),
            });
          });

          const stateSelect = document.createElement("select");
          const stateOptions = [
            { value: "all", label: "Tutti" },
            ...TASK_STATES.map((state) => ({
              value: state.id,
              label: state.label,
            })),
          ];
          stateOptions.forEach((option) => {
            const el = document.createElement("option");
            el.value = option.value;
            el.textContent = option.label;
            stateSelect.appendChild(el);
          });
          stateSelect.value = TaskFilters.state;
          stateSelect.addEventListener("change", () =>
            updateTaskFilters({ state: stateSelect.value })
          );

          const dueFromInput = document.createElement("input");
          dueFromInput.type = "date";
          dueFromInput.value = TaskFilters.dueFrom || "";
          dueFromInput.addEventListener("change", () =>
            updateTaskFilters({ dueFrom: dueFromInput.value || null })
          );
          dueFromInput.addEventListener("input", () =>
            updateTaskFilters({ dueFrom: dueFromInput.value || null })
          );

          const dueToInput = document.createElement("input");
          dueToInput.type = "date";
          dueToInput.value = TaskFilters.dueTo || "";
          dueToInput.addEventListener("change", () =>
            updateTaskFilters({ dueTo: dueToInput.value || null })
          );
          dueToInput.addEventListener("input", () =>
            updateTaskFilters({ dueTo: dueToInput.value || null })
          );

          const searchInput = document.createElement("input");
          searchInput.type = "text";
          searchInput.placeholder = "Cerca titolo o descrizione…";
          searchInput.value = taskSearchDraft || "";
          searchInput.addEventListener("input", () => {
            taskSearchDraft = searchInput.value;
          });
          searchInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              updateTaskFilters({ search: taskSearchDraft });
            }
          });

          container.append(
            createFilterField("Ruolo", roleSelect),
            createFilterField("LT", ltSelect),
            createFilterField("BT", stSelect),
            createFilterField("Importanza da", importanceMinInput),
            createFilterField("Importanza a", importanceMaxInput),
            createFilterField("Scadenza da", dueFromInput),
            createFilterField("Scadenza a", dueToInput),
            createFilterField("Stato", stateSelect),
            createFilterField("Ricerca", searchInput),
            button("Esporta CSV", "", () => onExport?.()),
            button("Importa CSV", "", () => onImport?.())
          );

          return container;
        }

        function createFilterField(label, control) {
          const wrapper = document.createElement("label");
          wrapper.className = "filter-field";
          const span = document.createElement("span");
          span.textContent = label;
          wrapper.append(span, control);
          return wrapper;
        }

        function selectRole(selectedId) {
          const select = document.createElement("select");
          AppState.data.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = role.title;
            select.appendChild(option);
          });
          if (selectedId) select.value = selectedId;
          return select;
        }

        function selectLongTerm(roleId, selectedId) {
          const select = document.createElement("select");
          const role = AppState.data.roles.find((r) => r.id === roleId);
          (role?.lt_goals || []).forEach((goal) => {
            const option = document.createElement("option");
            option.value = goal.id;
            option.textContent = goal.title;
            select.appendChild(option);
          });
          if (selectedId) select.value = selectedId;
          return select;
        }

        function createTaskStateSelect(task) {
          const select = document.createElement("select");
          select.className = "task-state-select";
          TASK_STATES.forEach((state) => {
            const option = document.createElement("option");
            option.value = state.id;
            option.textContent = state.label;
            select.appendChild(option);
          });
          select.value = getTaskStateId(task.state);
          updateTaskStateSelectStyle(select);
          select.addEventListener("change", () => {
            const previous = getTaskStateId(task.state);
            const desired = select.value;
            if (!applyTaskStateChange(task, desired)) {
              select.value = previous;
              updateTaskStateSelectStyle(select);
              return;
            }
            select.value = getTaskStateId(task.state);
            updateTaskStateSelectStyle(select);
            AppState.persist();
            rerenderTaskView();
          });
          return select;
        }

        function updateTaskStateSelectStyle(select) {
          const config = getTaskStateConfig(select.value);
          if (!config) return;
          select.style.setProperty("--state-color", config.color);
          select.style.borderColor = config.color;
          select.style.boxShadow = `0 0 0 1px ${config.color} inset`;
          select.title = config.label;
        }

        function createBadge(text) {
          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = text;
          return badge;
        }

        function truncateText(value, max) {
          const text = (value || "").trim();
          if (!text) return "—";
          return text.length > max ? `${text.slice(0, max - 1)}…` : text;
        }

        function confirmDelete(message) {
          return window.confirm(message || "Sei sicuro? Questa azione è irreversibile.");
        }

        function makeTable(columns, rows) {
          const wrapper = document.createElement("div");
          wrapper.style.overflowX = "auto";

          const table = document.createElement("table");
          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");

          let sortIndex = -1;
          let sortDir = 1;

          function defaultComparator(a, b) {
            if (a == null && b == null) return 0;
            if (a == null) return -1;
            if (b == null) return 1;
            if (a > b) return 1;
            if (a < b) return -1;
            return 0;
          }

          function applySort() {
            if (sortIndex < 0) return;
            const column = columns[sortIndex];
            const comparator = column.sort || ((rowA, rowB) => {
              const key = column.key;
              const a = typeof key === "function" ? key(rowA) : undefined;
              const b = typeof key === "function" ? key(rowB) : undefined;
              return defaultComparator(a, b);
            });
            rows.sort((a, b) => sortDir * comparator(a, b));
          }

          columns.forEach((column, idx) => {
            const th = document.createElement("th");
            th.textContent = column.label;
            if (column.key || column.sort) {
              th.classList.add("sortable");
              th.addEventListener("click", () => {
                if (sortIndex === idx) {
                  sortDir = -sortDir;
                } else {
                  sortIndex = idx;
                  sortDir = 1;
                }

                [...headerRow.children].forEach((el, headerIdx) => {
                  el.classList.remove("asc", "desc");
                  if (headerIdx === sortIndex) {
                    el.classList.add(sortDir === 1 ? "asc" : "desc");
                  }
                });

                applySort();
                renderBody();
              });
            }
            headerRow.appendChild(th);
          });

          thead.appendChild(headerRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");

          function renderBody() {
            tbody.innerHTML = "";
            rows.forEach((row) => {
              const tr = document.createElement("tr");
              columns.forEach((column) => {
                const td = document.createElement("td");
                td.appendChild(column.render(row));
                tr.appendChild(td);
              });
              tbody.appendChild(tr);
            });
          }

          applySort();
          renderBody();

          table.appendChild(tbody);
          wrapper.appendChild(table);
          return wrapper;
        }

        // =============================================================
        // Tab: Ruoli
        // =============================================================
        function renderRoles() {
          dom.view.innerHTML = "";
          const rows = AppState.data.roles.slice();

          const table = makeTable(
            [
              {
                label: "Titolo",
                key: (role) => (role.title || "").toLowerCase(),
                render: (role) =>
                  inputText(role.title, "Titolo", (value) => {
                    role.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Importanza (≥1)",
                key: (role) => role.importance || 0,
                  render: (role) => {
                      const el = inputInteger(role.importance, (value) => {
                          role.importance = toImportance(value ?? 1); // solo stato
                      });
                      const commit = () => {
                          cascadeFromRole(role);
                          AppState.persist();
                          render();
                      };
                      el.addEventListener("blur", commit);
                      el.addEventListener("change", commit); // per sicurezza
                      el.addEventListener("keydown", (e) => { if (e.key === "Enter") el.blur(); });
                      return el;
                  },
              },
              {
                label: "Azioni",
                render: (role) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.append(
                    button("+ LT", "", () => {
                      role.lt_goals.push(
                        createLongTerm(
                          "Nuovo obiettivo LT",
                          "",
                          3,
                          DateUtils.addDays(90)
                        )
                      );
                      AppState.persist();
                      render();
                    }),
                    button("Elimina", "", () => {
                      if (!confirmDelete("Eliminare ruolo e tutti i figli?"))
                        return;
                      role.lt_goals.forEach((lt) =>
                        lt.st_goals?.forEach((st) => detachShortTermFromSprint(st))
                      );
                      AppState.data.roles = AppState.data.roles.filter(
                        (candidate) => candidate.id !== role.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Ruolo", "primary", () => {
              AppState.data.roles.push(createRole("Nuovo ruolo", 3));
              AppState.persist();
              render();
            })
          );

          dom.view.append(toolbar, table);
        }

        // =============================================================
        // Tab: Obiettivi Lungo Termine (LT)
        // =============================================================
        function renderLongTermGoals() {
          dom.view.innerHTML = "";
          const rows = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) => rows.push({ role, lt }))
          );

          const table = makeTable(
            [
              {
                label: "Ruolo",
                key: (row) => (row.role.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectRole(row.role.id);
                  select.addEventListener("input", () => {
                    const from = row.role;
                    const to = AppState.data.roles.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!to || from.id === to.id) return;
                    from.lt_goals = from.lt_goals.filter(
                      (goal) => goal.id !== row.lt.id
                    );
                    to.lt_goals.push(row.lt);
                    row.role = to;
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Titolo",
                key: (row) => (row.lt.title || "").toLowerCase(),
                render: (row) =>
                  inputText(row.lt.title, "Titolo", (value) => {
                    row.lt.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Descrizione",
                render: (row) =>
                  textArea(row.lt.description, (value) => {
                    row.lt.description = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Importanza (≥1)",
                key: (row) => row.lt.importance || 0,
                render: (row) =>
                    (() => {
                        const el = inputInteger(row.lt.importance, (value) => {
                            row.lt.importance = toImportance(value ?? 1);
                        });
                        const commit = () => {
                            clampChildToParent(row.lt, row.role);
                            cascadeFromRole(row.role);
                            AppState.persist();
                            render();
                        };
                        el.addEventListener("blur", commit);
                        el.addEventListener("change", commit);
                        el.addEventListener("keydown", (e) => { if (e.key === "Enter") el.blur(); });
                        return el;
                    })(),
              },
              {
                label: "Scadenza",
                key: (row) => row.lt.due || "",
                render: (row) =>
                    (() => {
                        const el = inputDate(row.lt.due, (value) => {
                            row.lt.due = value || DateUtils.today();
                            }, { readOnly: false }); // ← Cambiato a false
                        const commit = () => {
                            clampChildToParent(row.lt, row.role);
                            cascadeFromRole(row.role);
                            AppState.persist();
                            render();
                        };
                        el.addEventListener("blur", commit);
                        el.addEventListener("change", commit);
                        return el;
                    })(),
              }
              ,
              {
                label: "Raggiunto il",
                key: (row) => row.lt.achieved_on || "",
                render: (row) => {
                  const span = document.createElement("span");
                  span.textContent = row.lt.achieved_on || "—";
                  return span;
                },
              },
              {
                label: "Azioni",
                render: (row) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.append(
                    button("+ BT", "", () => {
                      const sprintId = ensureCurrentSprintId().id;
                      const newSt = createShortTerm(
                        "Nuovo obiettivo BT",
                        "",
                        null,
                        null,
                        { sprintId }
                      );
                      row.lt.st_goals.push(newSt);
                      attachShortTermToSprint(newSt, sprintId);
                      AppState.persist();
                      render();
                    }),
                    button("On goal", "", () => {
                      const value = promptForIsoDate(
                        "Data effettiva raggiungimento LT (YYYY-MM-DD)",
                        row.lt.achieved_on || isoToday()
                      );
                      if (value === null) return;
                      row.lt.achieved_on = value ? value : null;
                      AppState.persist();
                      render();
                    }),
                    button("Elimina", "", () => {
                      if (
                        !confirmDelete(
                          "Eliminare obiettivo LT e tutti i figli?"
                        )
                      )
                        return;
                      row.lt.st_goals.forEach((st) =>
                        detachShortTermFromSprint(st)
                      );
                      row.role.lt_goals = row.role.lt_goals.filter(
                        (candidate) => candidate.id !== row.lt.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Obiettivo LT", "primary", () => {
              if (!AppState.data.roles.length) {
                alert("Prima crea almeno un Ruolo.");
                return;
              }
              AppState.data.roles[0].lt_goals.push(
                createLongTerm(
                  "Nuovo obiettivo LT",
                  "",
                  3,
                  DateUtils.addDays(120)
                )
              );
              AppState.persist();
              render();
            })
          );

          dom.view.append(toolbar, table);
        }

        // =============================================================
        // Tab: Obiettivi Breve Termine (ST)
        // =============================================================
        function renderShortTermGoals() {
          dom.view.innerHTML = "";

          const ensured = ensureCurrentSprintId();
          if (ensured.created) {
            AppState.persist();
          }
          if (!selectedSprintId && ensured.id) {
            updateSelectedSprint(ensured.id);
          }

          const sprints = Array.isArray(AppState.data.sprints)
            ? AppState.data.sprints.slice()
            : [];
          const sortedSprints = sprints.sort((a, b) => {
            const startA = a.start || "";
            const startB = b.start || "";
            if (startA && startB && startA !== startB) {
              return startA.localeCompare(startB);
            }
            return (a.name || "").localeCompare(b.name || "");
          });

          if (
            !sortedSprints.some((sprint) => sprint.id === selectedSprintId)
          ) {
            const fallbackId =
              AppState.data.currentSprintId || sortedSprints[0]?.id || null;
            if (fallbackId) {
              updateSelectedSprint(fallbackId);
            }
          }

          const selectedSprint =
            sortedSprints.find((sprint) => sprint.id === selectedSprintId) ||
            sortedSprints[0] ||
            null;

          const sprintStripWrapper = document.createElement("div");
          sprintStripWrapper.className = "sprint-strip-wrapper";
          const sprintStrip = document.createElement("div");
          sprintStrip.className = "sprint-strip";

          const selectedIndex = selectedSprint
            ? sortedSprints.findIndex((s) => s.id === selectedSprint.id)
            : -1;
          const prevSprint =
            selectedIndex > 0 ? sortedSprints[selectedIndex - 1] : null;
          const nextSprint =
            selectedIndex >= 0 && selectedIndex < sortedSprints.length - 1
              ? sortedSprints[selectedIndex + 1]
              : null;

          const prevBtn = button("←", "sprint-nav", () => {
            if (prevSprint) {
              updateSelectedSprint(prevSprint.id, { rerenderShortTerm: true });
            }
          });
          prevBtn.disabled = !prevSprint;

          const nextBtn = button("→", "sprint-nav", () => {
            if (nextSprint) {
              updateSelectedSprint(nextSprint.id, { rerenderShortTerm: true });
            }
          });
          nextBtn.disabled = !nextSprint;

          sprintStripWrapper.append(prevBtn, sprintStrip, nextBtn);

          if (sortedSprints.length) {
            const currentIndex = selectedIndex >= 0 ? selectedIndex : 0;
            const startIndex = Math.max(0, currentIndex - 3);
            const endIndex = Math.min(
              sortedSprints.length - 1,
              currentIndex + 3
            );
            for (let idx = startIndex; idx <= endIndex; idx += 1) {
              const sprint = sortedSprints[idx];
              const pill = document.createElement("button");
              pill.type = "button";
              pill.className = `sprint-pill${
                sprint.id === selectedSprintId ? " selected" : ""
              }${
                sprint.id === AppState.data.currentSprintId ? " current" : ""
              }`;
              const name = document.createElement("span");
              name.className = "sprint-name";
              name.textContent = sprint.name || "Sprint";
              const dates = document.createElement("span");
              dates.className = "sprint-dates";
              dates.textContent = formatSprintRange(sprint);
              pill.append(name, dates);
              pill.addEventListener("click", () => {
                updateSelectedSprint(sprint.id, { rerenderShortTerm: true });
              });
              sprintStrip.appendChild(pill);
            }
          }

          const sprintActions = document.createElement("div");
          sprintActions.className = "controls";
          sprintActions.append(
            button("+ Sprint", "primary", () => {
              const newSprint = createSprint(
                `Sprint ${AppState.data.sprints.length + 1}`,
                DateUtils.today(),
                DateUtils.addDays(14)
              );
              AppState.data.sprints.push(newSprint);
              AppState.data.currentSprintId = newSprint.id;
              updateSelectedSprint(newSprint.id);
              AppState.persist();
              render();
            })
          );

          if (
            selectedSprint &&
            AppState.data.currentSprintId !== selectedSprint.id
          ) {
            sprintActions.append(
              button("Imposta come corrente", "", () => {
                AppState.data.currentSprintId = selectedSprint.id;
                AppState.persist();
                render();
              })
            );
          }

          if (selectedSprint) {
            const deleteSprintBtn = button("Elimina sprint", "", () => {
              if (
                (selectedSprint.st_goal_ids || []).length &&
                !confirmDelete(
                  "Lo sprint contiene obiettivi BT. Svuotarlo prima di eliminarlo?"
                )
              ) {
                return;
              }
              if ((selectedSprint.st_goal_ids || []).length) {
                alert(
                  "Rimuovi gli obiettivi BT dallo sprint prima di eliminarlo."
                );
                return;
              }
              AppState.data.sprints = AppState.data.sprints.filter(
                (candidate) => candidate.id !== selectedSprint.id
              );
              if (AppState.data.currentSprintId === selectedSprint.id) {
                AppState.data.currentSprintId =
                  AppState.data.sprints[0]?.id || null;
              }
              updateSelectedSprint(
                AppState.data.currentSprintId || AppState.data.sprints[0]?.id || null
              );
              AppState.persist();
              render();
            });
            if ((selectedSprint.st_goal_ids || []).length) {
              deleteSprintBtn.disabled = true;
              deleteSprintBtn.title =
                "Sposta o elimina gli obiettivi BT prima di eliminare lo sprint.";
            }
            sprintActions.append(deleteSprintBtn);
          }

          const sprintDetails = document.createElement("div");
          sprintDetails.style.display = "grid";
          sprintDetails.style.gridTemplateColumns =
            "repeat(auto-fit, minmax(180px, 1fr))";
          sprintDetails.style.gap = "0.75rem";
          sprintDetails.style.marginBottom = "0.5rem";

          if (selectedSprint) {
            const nameControl = inputText(
              selectedSprint.name || "",
              "Nome sprint",
              (value) => {
                selectedSprint.name = value;
              }
            );
            nameControl.addEventListener("blur", () => {
              AppState.persist();
              render();
            });

            const startControl = inputDate(
              selectedSprint.start,
              (value) => {
                selectedSprint.start = value || null;
              },
              { readOnly: false }
            );
            startControl.addEventListener("blur", () => {
              AppState.persist();
              render();
            });

            const endControl = inputDate(
              selectedSprint.end,
              (value) => {
                selectedSprint.end = value || null;
              },
              { readOnly: false }
            );
            endControl.addEventListener("blur", () => {
              AppState.persist();
              render();
            });

            sprintDetails.append(
              labeledControl("Nome", nameControl),
              labeledControl("Inizio", startControl),
              labeledControl("Fine", endControl)
            );
          }

          const rows = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) =>
              lt.st_goals.forEach((st) => {
                if (selectedSprint && st.sprint_id !== selectedSprint.id) {
                  return;
                }
                rows.push({ role, lt, st });
              })
            )
          );

          const table = makeTable(
            [
              {
                label: "Ruolo",
                key: (row) => (row.role.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectRole(row.role.id);
                  select.addEventListener("input", () => {
                    const newRole = AppState.data.roles.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!newRole || newRole.id === row.role.id) return;
                    row.lt.st_goals = row.lt.st_goals.filter(
                      (candidate) => candidate.id !== row.st.id
                    );
                    if (!newRole.lt_goals.length) {
                      newRole.lt_goals.push(
                        createLongTerm(
                          "Auto creato",
                          "",
                          row.lt.importance,
                          row.lt.due
                        )
                      );
                    }
                    const targetLT = newRole.lt_goals[0];
                    targetLT.st_goals.push(row.st);
                    row.role = newRole;
                    row.lt = targetLT;
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "LT",
                key: (row) => (row.lt.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectLongTerm(row.role.id, row.lt.id);
                  select.addEventListener("input", () => {
                    const target = row.role.lt_goals.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!target) return;
                    row.lt.st_goals = row.lt.st_goals.filter(
                      (candidate) => candidate.id !== row.st.id
                    );
                    target.st_goals.push(row.st);
                    row.lt = target;
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Titolo",
                key: (row) => (row.st.title || "").toLowerCase(),
                render: (row) =>
                  inputText(row.st.title, "Titolo", (value) => {
                    row.st.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Descrizione",
                render: (row) =>
                  textArea(row.st.description, (value) => {
                    row.st.description = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Importanza (ereditata se vuota)",
                key: (row) =>
                  effectiveImportance(row.st, row.lt.importance ?? 1) || 0,
                render: (row) => {
                  const el = inputInteger(row.st.importance, (value) => {
                    row.st.importance = value;
                    enforceBounds();
                  });

                  const enforceBounds = () => {
                    const parentImportance = effectiveImportance(
                      row.lt,
                      row.role.importance ?? 1
                    );
                    if (
                      row.st.importance != null &&
                      parentImportance != null &&
                      row.st.importance > parentImportance
                    ) {
                      row.st.importance = parentImportance;
                      el.value = String(parentImportance);
                    }
                  };

                  const commit = () => {
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  };

                  el.addEventListener("blur", commit);
                  el.addEventListener("change", commit);
                  el.addEventListener("keydown", (event) => {
                    if (event.key === "Enter") el.blur();
                  });

                  enforceBounds();

                  return el;
                },
              },
              {
                label: "Scadenza (ereditata se vuota)",
                key: (row) => effectiveDueDate(row.st, row.lt.due) || "",
                render: (row) => {
                  const el = inputDate(
                    row.st.due,
                    (value) => {
                      row.st.due = value;
                    },
                    { readOnly: false }
                  );
                  el.addEventListener("blur", () => {
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  });
                  return el;
                },
              },
              {
                label: "Sprint",
                key: (row) => row.st.sprint_id || "",
                render: (row) => {
                  const select = document.createElement("select");
                  AppState.data.sprints.forEach((sprint) => {
                    const option = document.createElement("option");
                    option.value = sprint.id;
                    option.textContent = sprint.name || formatSprintRange(sprint);
                    select.appendChild(option);
                  });
                  if (!row.st.sprint_id && AppState.data.sprints.length) {
                    row.st.sprint_id = AppState.data.sprints[0].id;
                  }
                  select.value = row.st.sprint_id || "";
                  select.addEventListener("change", () => {
                    attachShortTermToSprint(row.st, select.value);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Raggiunto il",
                key: (row) => row.st.achieved_on || "",
                render: (row) => {
                  const span = document.createElement("span");
                  span.textContent = row.st.achieved_on || "—";
                  return span;
                },
              },
              {
                label: "Azioni",
                render: (row) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.append(
                    button("+ Attività", "", () => {
                      const task = createTask("Nuova attività", "", null, null);
                      row.st.tasks.push(task);
                      AppState.persist();
                      render();
                    }),
                    button("On goal", "", () => {
                      const value = promptForIsoDate(
                        "Data effettiva raggiungimento BT (YYYY-MM-DD)",
                        row.st.achieved_on || isoToday()
                      );
                      if (value === null) return;
                      row.st.achieved_on = value ? value : null;
                      AppState.persist();
                      render();
                    }),
                    button("Elimina", "", () => {
                      if (!confirmDelete("Eliminare obiettivo BT?")) return;
                      detachShortTermFromSprint(row.st);
                      row.lt.st_goals = row.lt.st_goals.filter(
                        (candidate) => candidate.id !== row.st.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Obiettivo BT", "primary", () => {
              if (!AppState.data.roles.length) {
                alert("Crea prima Ruolo > LT");
                return;
              }
              const role = AppState.data.roles[0];
              if (!role.lt_goals.length) {
                role.lt_goals.push(
                  createLongTerm(
                    "Nuovo obiettivo LT",
                    "",
                    3,
                    DateUtils.addDays(120)
                  )
                );
              }
              const sprintId =
                selectedSprintId || ensureCurrentSprintId().id || null;
              const newSt = createShortTerm(
                "Nuovo obiettivo BT",
                "",
                null,
                null,
                { sprintId }
              );
              role.lt_goals[0].st_goals.push(newSt);
              attachShortTermToSprint(newSt, sprintId);
              AppState.persist();
              render();
            })
          );

          dom.view.append(
            sprintStripWrapper,
            sprintActions,
            sprintDetails,
            toolbar,
            table
          );
        }

        // =============================================================
        // Tab: Attività
        // =============================================================
        function renderTasks() {
          dom.view.innerHTML = "";
          const rows = getFilteredTaskRefs();

          const filtersBar = createTaskFiltersBar({
            onExport: () => exportTasksToCsv(getFilteredTaskRefs()),
            onImport: () => requestTaskCsvImport(),
          });

          const table = makeTable(
            [
              {
                label: "Ruolo",
                key: (row) => (row.role.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectRole(row.role.id);
                  select.addEventListener("input", () => {
                    const newRole = AppState.data.roles.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!newRole || newRole.id === row.role.id) return;
                    row.st.tasks = row.st.tasks.filter(
                      (candidate) => candidate.id !== row.task.id
                    );
                    if (!newRole.lt_goals.length) {
                      newRole.lt_goals.push(
                        createLongTerm(
                          "Auto creato",
                          "",
                          row.lt.importance,
                          row.lt.due
                        )
                      );
                    }
                    const targetLT = newRole.lt_goals[0];
                    if (!targetLT.st_goals.length) {
                      const autoSt = createShortTerm(
                        "Auto creato",
                        "",
                        row.st.importance,
                        row.st.due,
                        { sprintId: row.st.sprint_id }
                      );
                      targetLT.st_goals.push(autoSt);
                      attachShortTermToSprint(autoSt, row.st.sprint_id);
                    }
                    const targetST = targetLT.st_goals[0];
                    targetST.tasks.push(row.task);
                    row.role = newRole;
                    row.lt = targetLT;
                    row.st = targetST;
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "LT",
                key: (row) => (row.lt.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectLongTerm(row.role.id, row.lt.id);
                  select.addEventListener("input", () => {
                    const target = row.role.lt_goals.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!target) return;
                    row.st.tasks = row.st.tasks.filter(
                      (candidate) => candidate.id !== row.task.id
                    );
                    if (!target.st_goals.length) {
                      const autoSt = createShortTerm(
                        "Auto creato",
                        "",
                        row.st.importance,
                        row.st.due,
                        { sprintId: row.st.sprint_id }
                      );
                      target.st_goals.push(autoSt);
                      attachShortTermToSprint(autoSt, row.st.sprint_id);
                    }
                    const targetST = target.st_goals[0];
                    targetST.tasks.push(row.task);
                    row.lt = target;
                    row.st = targetST;
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "BT",
                key: (row) => (row.st.title || "").toLowerCase(),
                render: (row) => {
                  const select = document.createElement("select");
                  row.lt.st_goals.forEach((st) => {
                    const option = document.createElement("option");
                    option.value = st.id;
                    option.textContent = st.title;
                    select.appendChild(option);
                  });
                  select.value = row.st.id;
                  select.addEventListener("input", () => {
                    const target = row.lt.st_goals.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!target) return;
                    row.st.tasks = row.st.tasks.filter(
                      (candidate) => candidate.id !== row.task.id
                    );
                    target.tasks.push(row.task);
                    row.st = target;
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Titolo",
                key: (row) => (row.task.title || "").toLowerCase(),
                render: (row) =>
                  inputText(row.task.title, "Titolo", (value) => {
                    row.task.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Descrizione",
                render: (row) =>
                  textArea(row.task.description, (value) => {
                    row.task.description = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Stato",
                key: (row) =>
                  getTaskStateConfig(row.task.state).label.toLowerCase(),
                render: (row) => createTaskStateSelect(row.task),
              },
              {
                label: "Importanza (ereditata se vuota)",
                key: (row) =>
                  effectiveImportance(
                    row.task,
                    effectiveImportance(row.st, row.lt.importance)
                  ) || 0,
                render: (row) => {
                  const el = inputInteger(row.task.importance, (value) => {
                    row.task.importance = value;
                  });
                  const commit = () => {
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  };
                  el.addEventListener("blur", commit);
                  el.addEventListener("change", commit);
                  el.addEventListener("keydown", (event) => {
                    if (event.key === "Enter") el.blur();
                  });
                  return el;
                },
              },
              {
                label: "Scadenza (ereditata se vuota)",
                key: (row) =>
                  effectiveDueDate(
                    row.task,
                    effectiveDueDate(row.st, row.lt.due)
                  ) || "",
                render: (row) => {
                  const el = inputDate(
                    row.task.due,
                    (value) => {
                      row.task.due = value;
                    },
                    { readOnly: false }
                  ); // ← Cambiato a false
                  el.addEventListener("blur", () => {
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return el;
                },
              },
              {
                label: "Chiuso il",
                key: (row) => row.task.closed_on || "",
                render: (row) => {
                  const el = inputDate(
                    row.task.closed_on,
                    (value) => {
                      row.task.closed_on = value || null;
                    },
                    { readOnly: false }
                  );
                  const persist = () => AppState.persist();
                  el.addEventListener("change", persist);
                  el.addEventListener("blur", persist);
                  return el;
                },
              },
              {
                label: "Azioni",
                render: (row) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.appendChild(
                    button("Elimina", "", () => {
                      if (!confirmDelete("Eliminare attività?")) return;
                      row.st.tasks = row.st.tasks.filter(
                        (candidate) => candidate.id !== row.task.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Attività", "primary", () => {
              if (!AppState.data.roles.length) {
                alert("Crea prima Ruolo > LT > BT");
                return;
              }
              const role = AppState.data.roles[0];
              if (!role.lt_goals.length) {
                role.lt_goals.push(
                  createLongTerm(
                    "Nuovo LT",
                    "",
                    3,
                    DateUtils.addDays(120)
                  )
                );
              }
              const lt = role.lt_goals[0];
              if (!lt.st_goals.length) {
                const sprintId = ensureCurrentSprintId().id;
                const autoSt = createShortTerm(
                  "Nuovo BT",
                  "",
                  null,
                  null,
                  { sprintId }
                );
                lt.st_goals.push(autoSt);
                attachShortTermToSprint(autoSt, sprintId);
              }
              lt.st_goals[0].tasks.push(
                createTask("Nuova attività", "", null, null)
              );
              AppState.persist();
              render();
            })
          );

          dom.view.append(filtersBar, toolbar, table);
        }

        // =============================================================
        // Tab: Dashboard
        // =============================================================
        function renderDashboard() {
          dom.view.innerHTML = "";
          const filtersBar = createTaskFiltersBar({
            onExport: () => exportTasksToCsv(getFilteredTaskRefs()),
            onImport: () => requestTaskCsvImport(),
          });
          const kanban = document.createElement("div");
          kanban.className = "kanban";

          const columns = new Map();
          TASK_STATES.forEach((state) => {
            const column = createKanbanColumn(state);
            columns.set(state.id, column);
            kanban.appendChild(column.element);
          });

          const refsByState = new Map();
          getFilteredTaskRefs().forEach((ref) => {
            const stateId = getTaskStateId(ref.task.state);
            if (!refsByState.has(stateId)) {
              refsByState.set(stateId, []);
            }
            refsByState.get(stateId).push(ref);
          });

          columns.forEach((column, stateId) => {
            column.body.innerHTML = "";
            const refs = refsByState.get(stateId) || [];
            refs.sort((a, b) => {
              const impA = effectiveImportance(
                a.task,
                effectiveImportance(a.st, a.lt.importance)
              ) ?? 0;
              const impB = effectiveImportance(
                b.task,
                effectiveImportance(b.st, b.lt.importance)
              ) ?? 0;
              return impB - impA;
            });

            refs.forEach((ref) => {
              column.body.appendChild(createKanbanCard(ref));
            });

            column.count = refs.length;
            column.countEl.textContent = String(column.count);

            if (!column.count) {
              column.body.appendChild(column.placeholder);
            }
          });

          dom.view.append(filtersBar, kanban);
        }

        function createKanbanColumn(state) {
          const column = document.createElement("section");
          column.className = "kanban-column";
          column.dataset.state = state.id;

          const header = document.createElement("div");
          header.className = "kanban-column-header";
          const title = document.createElement("span");
          title.textContent = state.label;
          const count = document.createElement("span");
          count.className = "kanban-column-count";
          count.textContent = "0";
          header.append(title, count);

          const body = document.createElement("div");
          body.className = "kanban-column-body";
          body.dataset.state = state.id;

          const placeholder = document.createElement("p");
          placeholder.className = "kanban-column-placeholder";
          placeholder.textContent = "Nessuna attività. Trascina qui per cambiare stato.";

          setupDropZone(column, [column, body, placeholder], state.id);

          column.append(header, body);

          return {
            element: column,
            body,
            countEl: count,
            placeholder,
            count: 0,
          };
        }

        function setupDropZone(columnElement, dropTargets, stateId) {
          const targets = Array.isArray(dropTargets)
            ? dropTargets
            : [dropTargets];

          const handleDragEnter = (event) => {
            event.preventDefault();
            columnElement.classList.add("dragover");
          };

          const handleDragOver = (event) => {
            event.preventDefault();
            event.dataTransfer.dropEffect = "move";
            columnElement.classList.add("dragover");
          };

          const handleDragLeave = (event) => {
            const destination = event.relatedTarget;
            if (!destination || !columnElement.contains(destination)) {
              columnElement.classList.remove("dragover");
            }
          };

          const handleDrop = (event) => {
            event.preventDefault();
            columnElement.classList.remove("dragover");
            const payload = event.dataTransfer.getData("text/plain");
            if (!payload) return;
            let identifiers;
            try {
              identifiers = JSON.parse(payload);
            } catch (error) {
              console.warn("Payload drop non valido", error);
              return;
            }
            if (!identifiers) return;
            const ref = findTaskRef(identifiers);
            if (!ref) return;
            const nextState = stateId;
            const previous = getTaskStateId(ref.task.state);
            if (previous === nextState) return;
            if (!applyTaskStateChange(ref.task, nextState)) {
              render();
              return;
            }
            AppState.persist();
            render();
          };

          targets.forEach((target) => {
            target.addEventListener("dragenter", handleDragEnter);
            target.addEventListener("dragover", handleDragOver);
            target.addEventListener("dragleave", handleDragLeave);
            target.addEventListener("drop", handleDrop);
          });
        }

        function createKanbanCard({ role, lt, st, task }) {
          const config = getTaskStateConfig(task.state);
          const card = document.createElement("article");
          card.className = "kanban-card";
          card.draggable = true;
          card.dataset.roleId = role.id;
          card.dataset.ltId = lt.id;
          card.dataset.stId = st.id;
          card.dataset.taskId = task.id;
          card.style.borderTop = `3px solid ${config.color}`;

          card.addEventListener("dragstart", (event) => {
            event.dataTransfer.effectAllowed = "move";
            event.dataTransfer.setData(
              "text/plain",
              JSON.stringify({
                roleId: role.id,
                ltId: lt.id,
                stId: st.id,
                taskId: task.id,
              })
            );
            card.classList.add("dragging");
          });

          card.addEventListener("dragend", () => {
            card.classList.remove("dragging");
          });

          const hierarchy = document.createElement("div");
          hierarchy.className = "kanban-card-hierarchy";
          hierarchy.textContent = [role.title, lt.title, st.title]
            .map((value) => value || "—")
            .join(" › ");

          const title = document.createElement("div");
          title.className = "title";
          title.textContent = task.title || "(Senza titolo)";

          const description = document.createElement("div");
          description.className = "description";
          description.textContent = truncateText(task.description, 140);

          const importance = effectiveImportance(
            task,
            effectiveImportance(st, lt.importance)
          );
          const due = effectiveDueDate(task, effectiveDueDate(st, lt.due));
          const meta = document.createElement("div");
          meta.className = "kanban-card-meta";
          meta.append(
            createBadge(`Imp: ${importance ?? "-"}`),
            createBadge(`Scadenza: ${due || "-"}`)
          );

          card.append(hierarchy, title, description, meta);
          return card;
        }

        // =============================================================
        // Factory function per creare nuovi elementi del dominio
        // =============================================================
        function createSprint(name, start, end, stGoalIds = [], id = null) {
          const sprintId = id != null ? String(id) : AppState.nextId();
          return {
            id: sprintId,
            name: name || `Sprint ${AppState.data.sprints.length + 1}`,
            start: sanitizeIsoDate(start),
            end: sanitizeIsoDate(end),
            st_goal_ids: Array.isArray(stGoalIds)
              ? stGoalIds.map((value) => String(value))
              : [],
          };
        }

        function createRole(title, importance) {
          return {
            id: AppState.nextId(),
            title,
            importance: toImportance(importance, 1),
            lt_goals: [],
          };
        }

        function createLongTerm(title, description, importance, due, achievedOn) {
          return {
            id: AppState.nextId(),
            title,
            description: description || "",
            importance: toImportance(importance, 1),
            due: due || DateUtils.today(),
            achieved_on: sanitizeIsoDate(achievedOn),
            st_goals: [],
          };
        }

        function createShortTerm(
          title,
          description,
          importance,
          due,
          { sprintId = null, achievedOn = null } = {}
        ) {
          const fallback = ensureCurrentSprintId().id;
          const targetSprintId = sprintId != null ? String(sprintId) : fallback;
          return {
            id: AppState.nextId(),
            title,
            description: description || "",
            importance: toImportanceOrNull(importance),
            due: due || null,
            achieved_on: sanitizeIsoDate(achievedOn),
            sprint_id: targetSprintId || null,
            tasks: [],
          };
        }

        function createTask(title, description, importance, due) {
          const task = {
            id: AppState.nextId(),
            title,
            description: description || "",
            importance: toImportanceOrNull(importance),
            due: due || null,
            state: DEFAULT_TASK_STATE,
            closed_on: null,
          };
          normalizeTask(task);
          return task;
        }

        // =============================================================
        // Export / Import CSV attività
        // =============================================================
        function exportTasksToCsv(taskRefs) {
          const lines = [TASK_CSV_HEADERS.join(",")];
          taskRefs.forEach(({ role, lt, st, task }) => {
            lines.push(
              [
                role.title || "",
                lt.title || "",
                st.title || "",
                task.title || "",
                task.description || "",
                task.importance ?? "",
                task.due || "",
                getTaskStateId(task.state),
              ]
                .map(escapeCsvValue)
                .join(",")
            );
          });

          const blob = new Blob([lines.join("\r\n")], {
            type: "text/csv;charset=utf-8;",
          });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = TASK_CSV_FILE_NAME;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(link.href);
        }

        function escapeCsvValue(value) {
          if (value == null) return "";
          const text = String(value);
          if (/[",\n\r]/.test(text)) {
            return `"${text.replace(/"/g, '""')}"`;
          }
          return text;
        }

        function importTasksFromCsvContent(content) {
          const rows = parseCsv(content);
          if (!rows.length) {
            throw new Error("CSV vuoto");
          }

          const headerRow = rows[0];
          const indexMap = buildCsvIndexMap(headerRow);
          const missingColumns = Object.keys(TASK_CSV_COLUMN_LABELS).filter(
            (key) => indexMap[key] === -1
          );
          if (missingColumns.length) {
            const labels = missingColumns
              .map((key) => TASK_CSV_COLUMN_LABELS[key])
              .join(", ");
            throw new Error(`Colonne mancanti nel CSV: ${labels}`);
          }

          let imported = 0;
          const touchedRoles = new Set();

          for (let i = 1; i < rows.length; i += 1) {
            const row = rows[i];
            if (!row || !row.length) continue;
            const normalizedRow = headerRow.map((_, idx) => row[idx] ?? "");
            if (normalizedRow.every((value) => !value.trim())) continue;

            const roleTitle = normalizedRow[indexMap.role];
            const ltTitle = normalizedRow[indexMap.lt];
            const stTitle = normalizedRow[indexMap.st];
            const title = normalizedRow[indexMap.title] || "Attività importata";
            const description = normalizedRow[indexMap.description] || "";
            const rawImportance = normalizedRow[indexMap.importance].trim();
            let importance = null;
            if (rawImportance) {
              const parsedImportance = Number.parseInt(rawImportance, 10);
              if (!Number.isNaN(parsedImportance)) {
                importance = parsedImportance;
              }
            }
            const due = sanitizeCsvDate(normalizedRow[indexMap.due]);
            const state = resolveTaskStateFromCsv(normalizedRow[indexMap.state]);

            const role = ensureRoleForImport(roleTitle);
            const lt = ensureLongTermForImport(role, ltTitle, due);
            const st = ensureShortTermForImport(lt, stTitle, due);

            const task = createTask(title, description, importance, due);
            task.state = state;
            normalizeTask(task);
            clampChildToParent(task, st.due ? st : lt);
            st.tasks.push(task);
            imported += 1;
            touchedRoles.add(role);
          }

          touchedRoles.forEach((role) => cascadeFromRole(role));
          if (!imported) {
            throw new Error("Nessuna attività trovata nel CSV");
          }
          return imported;
        }

        function buildCsvIndexMap(headerRow) {
          const normalized = headerRow.map(normalizeForComparison);
          const map = {};
          Object.entries(TASK_CSV_COLUMN_ALIASES).forEach(([key, aliases]) => {
            map[key] = normalized.findIndex((value) =>
              aliases.some((alias) => normalizeForComparison(alias) === value)
            );
          });
          return map;
        }

        function parseCsv(content) {
          const rows = [];
          let current = [];
          let currentValue = "";
          let inQuotes = false;

          for (let i = 0; i < content.length; i += 1) {
            const char = content[i];
            if (inQuotes) {
              if (char === '"') {
                if (content[i + 1] === '"') {
                  currentValue += '"';
                  i += 1;
                } else {
                  inQuotes = false;
                }
              } else {
                currentValue += char;
              }
              continue;
            }

            if (char === '"') {
              inQuotes = true;
            } else if (char === ',') {
              current.push(currentValue);
              currentValue = "";
            } else if (char === '\r') {
              // ignore
            } else if (char === '\n') {
              current.push(currentValue);
              rows.push(current);
              current = [];
              currentValue = "";
            } else {
              currentValue += char;
            }
          }

          current.push(currentValue);
          if (current.length > 1 || current[0] !== "") {
            rows.push(current);
          }
          return rows;
        }

        function normalizeForComparison(value) {
          return value
            ? value
                .toString()
                .trim()
                .toLowerCase()
                .normalize("NFD")
                .replace(/\p{Diacritic}/gu, "")
            : "";
        }

        function resolveTaskStateFromCsv(value) {
          const normalized = normalizeForComparison(value);
          if (!normalized) return DEFAULT_TASK_STATE;
          for (const state of TASK_STATES) {
            if (normalizeForComparison(state.id) === normalized) {
              return state.id;
            }
            if (normalizeForComparison(state.label) === normalized) {
              return state.id;
            }
          }
          return DEFAULT_TASK_STATE;
        }

        function sanitizeCsvDate(value) {
          const trimmed = (value || "").trim();
          if (!trimmed) return null;
          if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) return trimmed;
          return null;
        }

        function ensureRoleForImport(title) {
          const finalTitle = title && title.trim() ? title.trim() : "Ruolo importato";
          const normalizedTitle = normalizeForComparison(finalTitle);
          let role = AppState.data.roles.find(
            (candidate) => normalizeForComparison(candidate.title) === normalizedTitle
          );
          if (!role) {
            role = createRole(finalTitle, 3);
            AppState.data.roles.push(role);
          }
          return role;
        }

        function ensureLongTermForImport(role, title, dueHint) {
          const finalTitle = title && title.trim()
            ? title.trim()
            : "Obiettivo LT importato";
          const normalizedTitle = normalizeForComparison(finalTitle);
          let lt = role.lt_goals.find(
            (candidate) => normalizeForComparison(candidate.title) === normalizedTitle
          );
          if (!lt) {
            const due = sanitizeCsvDate(dueHint) || DateUtils.addDays(365);
            lt = createLongTerm(finalTitle, "", role.importance, due);
            clampChildToParent(lt, role);
            role.lt_goals.push(lt);
          }
          return lt;
        }

        function ensureShortTermForImport(lt, title, dueHint) {
          const finalTitle = title && title.trim()
            ? title.trim()
            : "Obiettivo BT importato";
          const normalizedTitle = normalizeForComparison(finalTitle);
          let st = lt.st_goals.find(
            (candidate) => normalizeForComparison(candidate.title) === normalizedTitle
          );
          if (!st) {
            const due = sanitizeCsvDate(dueHint) || null;
            const sprintId = ensureCurrentSprintId().id;
            st = createShortTerm(finalTitle, "", null, due, { sprintId });
            clampChildToParent(st, lt);
            lt.st_goals.push(st);
            attachShortTermToSprint(st, sprintId);
          } else if (st.sprint_id) {
            attachShortTermToSprint(st, st.sprint_id);
          }
          return st;
        }

        // =============================================================
        // Export / Import JSON
        // =============================================================
        dom.exportBtn.addEventListener("click", () => {
          const blob = new Blob([JSON.stringify(AppState.data, null, 2)], {
            type: "application/json",
          });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = DEFAULT_FILE_NAME;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(link.href);
        });

        dom.importBtn.addEventListener("click", () => dom.filePicker.click());

        dom.filePicker.addEventListener("change", async (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          try {
            const content = await file.text();
            const parsed = JSON.parse(content);
            if (!validate(parsed)) {
              alert("JSON non valido");
              return;
            }
            AppState.replace(parsed);
            render();
          } catch (error) {
            alert(`Errore import: ${error.message}`);
          } finally {
            dom.filePicker.value = "";
          }
        });

        // =============================================================
        // File System Access API
        // =============================================================
        const FileSystem = {
          supported:
            "showSaveFilePicker" in window && "showOpenFilePicker" in window,
        };

        dom.saveFileBtn.addEventListener("click", async () => {
          if (!FileSystem.supported) {
            alert(
              "Il tuo browser non supporta il salvataggio diretto. Usa Esporta JSON."
            );
            return;
          }
          try {
            if (!AppState.currentFileHandle) {
              AppState.currentFileHandle = await window.showSaveFilePicker({
                suggestedName: DEFAULT_FILE_NAME,
                types: [
                  {
                    description: "JSON",
                    accept: { "application/json": [".json"] },
                  },
                ],
              });
            }
            const writable = await AppState.currentFileHandle.createWritable();
            await writable.write(JSON.stringify(AppState.data, null, 2));
            await writable.close();
            alert("Salvato ✅");
          } catch (error) {
            if (error.name !== "AbortError") {
              alert(`Errore salvataggio: ${error.message}`);
            }
          }
        });

        dom.openFileBtn.addEventListener("click", async () => {
          if (!FileSystem.supported) {
            alert(
              "Il tuo browser non supporta l'apertura diretta. Usa Importa JSON."
            );
            return;
          }
          try {
            const [handle] = await window.showOpenFilePicker({
              types: [
                {
                  description: "JSON",
                  accept: { "application/json": [".json"] },
                },
              ],
            });
            AppState.currentFileHandle = handle;
            const file = await handle.getFile();
            const content = await file.text();
            const parsed = JSON.parse(content);
            if (!validate(parsed)) {
              alert("JSON non valido");
              return;
            }
            AppState.replace(parsed);
            render();
          } catch (error) {
            if (error.name !== "AbortError") {
              alert(`Errore apertura: ${error.message}`);
            }
          }
        });

        dom.clearBtn.addEventListener("click", () => {
          if (!confirmDelete("Sicuro di azzerare tutto?")) return;
          AppState.replace(defaultState());
          render();
        });

        // =============================================================
        // Google Drive integration (opzionale)
        // =============================================================
        function padNumber(value, length) {
          return String(value).padStart(length, "0");
        }

        function buildTimestampedDriveFileName(date = new Date()) {
          const year = date.getFullYear();
          const month = padNumber(date.getMonth() + 1, 2);
          const day = padNumber(date.getDate(), 2);
          const hours = padNumber(date.getHours(), 2);
          const minutes = padNumber(date.getMinutes(), 2);
          const seconds = padNumber(date.getSeconds(), 2);
          const millis = padNumber(date.getMilliseconds(), 3);
          return `${DRIVE_FILE_PREFIX}_${year}${month}${day}_${hours}${minutes}_${seconds}_${millis}.json`;
        }

        const GoogleDrive = {
          CLIENT_ID: localStorage.getItem(STORAGE_KEYS.GD_CLIENT_ID) || "",
          API_KEY: localStorage.getItem(STORAGE_KEYS.GD_API_KEY) || "",
          DISCOVERY_DOCS: GOOGLE_DISCOVERY_DOCS,
          SCOPES: GOOGLE_SCOPE,
          tokenClient: null,
          gapiLoaded: false,
          gisLoaded: false,
          signedIn: false,
          currentFileId: null,
          folderName: DRIVE_FOLDER_NAME,
          folderId: localStorage.getItem(STORAGE_KEYS.GD_FOLDER_ID) || null,
        };

        function updateDriveUI() {
          dom.driveStatus.textContent = GoogleDrive.signedIn
            ? "Drive: connesso"
            : "Drive: offline";
          dom.driveOpenBtn.disabled = !GoogleDrive.signedIn;
          dom.driveSaveBtn.disabled = !GoogleDrive.signedIn;
        }

        function saveDriveCredentials() {
          localStorage.setItem(STORAGE_KEYS.GD_CLIENT_ID, GoogleDrive.CLIENT_ID);
          localStorage.setItem(STORAGE_KEYS.GD_API_KEY, GoogleDrive.API_KEY);
        }

        function persistDriveFolderId(id) {
          GoogleDrive.folderId = id || null;
          if (GoogleDrive.folderId) {
            localStorage.setItem(STORAGE_KEYS.GD_FOLDER_ID, GoogleDrive.folderId);
          } else {
            localStorage.removeItem(STORAGE_KEYS.GD_FOLDER_ID);
          }
        }

        function askForDriveCredentials() {
          const clientId = prompt(
            "Inserisci il tuo Google OAuth CLIENT_ID (tipo ...apps.googleusercontent.com):",
            GoogleDrive.CLIENT_ID || ""
          );
          if (!clientId) return false;
          const apiKey = prompt(
            "Inserisci la tua Google API KEY:",
            GoogleDrive.API_KEY || ""
          );
          if (!apiKey) return false;
          GoogleDrive.CLIENT_ID = clientId.trim();
          GoogleDrive.API_KEY = apiKey.trim();
          saveDriveCredentials();
          return true;
        }

        function loadGapi() {
          return new Promise((resolve, reject) => {
            if (GoogleDrive.gapiLoaded) {
              resolve();
              return;
            }
            const script = document.createElement("script");
            script.src = "https://apis.google.com/js/api.js";
            script.onload = () => {
              gapi.load("client", async () => {
                try {
                  await gapi.client.init({
                    apiKey: GoogleDrive.API_KEY,
                    discoveryDocs: GoogleDrive.DISCOVERY_DOCS,
                  });
                  GoogleDrive.gapiLoaded = true;
                  resolve();
                } catch (error) {
                  reject(error);
                }
              });
            };
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        function loadGoogleIdentityServices() {
          return new Promise((resolve, reject) => {
            if (GoogleDrive.gisLoaded) {
              resolve();
              return;
            }
            const script = document.createElement("script");
            script.src = "https://accounts.google.com/gsi/client";
            script.onload = () => {
              try {
                GoogleDrive.tokenClient = google.accounts.oauth2.initTokenClient({
                  client_id: GoogleDrive.CLIENT_ID,
                  scope: GoogleDrive.SCOPES,
                  callback: (response) => {
                    if (response && response.access_token) {
                      GoogleDrive.signedIn = true;
                      updateDriveUI();
                    }
                  },
                });
                GoogleDrive.gisLoaded = true;
                resolve();
              } catch (error) {
                reject(error);
              }
            };
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        async function ensureDriveReady() {
         // if (location.protocol === "file:") {
         //   alert(
         //     "Per usare Google Drive apri la pagina da http://localhost o https://"
         //   );
         //   return false;
         // }
          if (!GoogleDrive.CLIENT_ID || !GoogleDrive.API_KEY) {
            const ok = askForDriveCredentials();
            if (!ok) return false;
          }
          try {
            await loadGoogleIdentityServices();
          } catch (error) {
            alert(`Errore GIS: ${error.message || error}`);
            return false;
          }
          try {
            await loadGapi();
          } catch (error) {
            console.warn("Uso fallback REST (senza discovery):", error);
          }
          return true;
        }

        async function ensureDriveFolder() {
          if (GoogleDrive.folderId) return GoogleDrive.folderId;
          const folderName = GoogleDrive.folderName;
          const query =
            "mimeType='application/vnd.google-apps.folder' and trashed=false and name='" +
            folderName +
            "'";
          const findWithGapi = async () => {
            if (!(GoogleDrive.gapiLoaded && window.gapi?.client?.drive)) return null;
            try {
              const response = await gapi.client.drive.files.list({
                q: query,
                fields: "files(id,name)",
                pageSize: 1,
              });
              return response.result.files?.[0] || null;
            } catch (error) {
              console.warn("Ricerca cartella via gapi fallita, provo fallback:", error);
              return null;
            }
          };

          const findWithRest = async () => {
            try {
              const response = await driveFetch("files", {
                q: query,
                fields: "files(id,name)",
                pageSize: "1",
              });
              return response.files?.[0] || null;
            } catch (error) {
              console.warn("Ricerca cartella via REST fallita:", error);
              return null;
            }
          };

          const createWithGapi = async () => {
            if (!(GoogleDrive.gapiLoaded && window.gapi?.client?.drive)) return null;
            try {
              const response = await gapi.client.drive.files.create({
                resource: {
                  name: folderName,
                  mimeType: "application/vnd.google-apps.folder",
                },
                fields: "id",
              });
              return { id: response.result?.id };
            } catch (error) {
              console.warn("Creazione cartella via gapi fallita, provo REST:", error);
              return null;
            }
          };

          const createWithRest = async () => {
            const response = await driveFetch(
              "files",
              { fields: "id" },
              "POST",
              {
                name: folderName,
                mimeType: "application/vnd.google-apps.folder",
              }
            );
            return { id: response.id };
          };

          let folder = (await findWithGapi()) || (await findWithRest());
          if (!folder) {
            folder = (await createWithGapi()) || (await createWithRest());
          }
          if (!folder?.id) {
            throw new Error(
              "Impossibile accedere o creare la cartella Kanban_Covey_BigRocks su Drive"
            );
          }
          persistDriveFolderId(folder.id);
          return folder.id;
        }

        async function driveFetch(path, params = {}, method = "GET", body = null) {
          const tokenObj = google.accounts.oauth2.getToken?.();
          const token = tokenObj && tokenObj.access_token;
          if (!token) throw new Error('Nessun access token disponibile. Premi "Connetti Google".');
          const url = new URL(`https://www.googleapis.com/drive/v3/${path}`);
          Object.entries(params).forEach(([key, value]) =>
            url.searchParams.set(key, value)
          );
          const response = await fetch(url.toString(), {
            method,
            headers: {
              Authorization: `Bearer ${token}`,
              ...(body ? { "Content-Type": "application/json" } : {}),
            },
            body: body ? JSON.stringify(body) : null,
          });
          if (!response.ok) {
            throw new Error(`Drive REST error ${response.status}: ${await response.text()}`);
          }
          return response.json();
        }

        async function listJsonFilesFallback(folderId) {
          const q = `'${folderId}' in parents and mimeType='application/json' and trashed=false`;
          return driveFetch("files", {
            q,
            fields: "files(id,name,modifiedTime)",
            pageSize: "25",
          });
        }

        async function getFileContentFallback(fileId) {
          const tokenObj = google.accounts.oauth2.getToken?.();
          const token = tokenObj && tokenObj.access_token;
          const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(
            fileId
          )}?alt=media`;
          const response = await fetch(url, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });
          if (!response.ok) {
            throw new Error(`Download error ${response.status}`);
          }
          return response.text();
        }

        async function uploadJsonFallback(name, content, folderId) {
          const boundary = "-------314159265358979323846";
          const delimiter = `\r\n--${boundary}\r\n`;
          const closeDelimiter = `\r\n--${boundary}--`;
          const metadata = {
            name,
            mimeType: "application/json",
            parents: [folderId],
          };
          const multipartBody =
            `${delimiter}Content-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(metadata)}` +
            `${delimiter}Content-Type: application/json\r\n\r\n${content}${closeDelimiter}`;

          const tokenObj = google.accounts.oauth2.getToken?.();
          const token = tokenObj && tokenObj.access_token;
          const response = await fetch(
            "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",
            {
              method: "POST",
              headers: {
                Authorization: `Bearer ${token}`,
                "Content-Type": `multipart/related; boundary=${boundary}`,
              },
              body: multipartBody,
            }
          );
          if (!response.ok) {
            throw new Error(`Upload error ${response.status}: ${await response.text()}`);
          }
          const json = await response.json();
          return json.id;
        }

        dom.googleBtn.addEventListener("click", async () => {
          if (!(await ensureDriveReady())) return;
          try {
            GoogleDrive.tokenClient.requestAccessToken({ prompt: "consent" });
          } catch (error) {
            alert(`Autorizzazione Google fallita: ${error.message || error}`);
          }
        });

        dom.driveOpenBtn.addEventListener("click", async () => {
          try {
            if (!(await ensureDriveReady())) return;
            const folderId = await ensureDriveFolder();
            let files = [];
            if (GoogleDrive.gapiLoaded && window.gapi?.client?.drive) {
              try {
                const response = await gapi.client.drive.files.list({
                  q: `'${folderId}' in parents and mimeType='application/json' and trashed=false`,
                  pageSize: 25,
                  fields: "files(id,name,modifiedTime)",
                });
                files = response.result.files || [];
              } catch (error) {
                console.warn("gapi list fallita, passo a REST fallback:", error);
              }
            }
            if (!files.length) {
              const response = await listJsonFilesFallback(folderId);
              files = response.files || [];
            }
            if (!files.length) {
              alert("Nessun JSON trovato nel tuo Drive.");
              return;
            }
            const nameList = files
              .map(
                (file, index) =>
                  `${index + 1}) ${file.name} — ${new Date(
                    file.modifiedTime
                  ).toLocaleString()}`
              )
              .join("\n");
            const idx = prompt(`Scegli file da aprire (numero):\n${nameList}`);
            const selectedIndex = Number(idx) - 1;
            if (!(selectedIndex >= 0 && selectedIndex < files.length)) return;
            const file = files[selectedIndex];
            let text;
            if (GoogleDrive.gapiLoaded && window.gapi?.client?.drive) {
              try {
                const download = await gapi.client.drive.files.get({
                  fileId: file.id,
                  alt: "media",
                });
                text = download.body;
              } catch (error) {
                console.warn("gapi download fallito, uso REST:", error);
                text = await getFileContentFallback(file.id);
              }
            } else {
              text = await getFileContentFallback(file.id);
            }
            const data = JSON.parse(text);
            if (!validate(data)) {
              alert("JSON non valido");
              return;
            }
            AppState.replace(data);
            GoogleDrive.currentFileId = file.id;
            alert(`Aperto da Drive: ${file.name}`);
            render();
          } catch (error) {
            alert(`Errore apertura Drive: ${error.message || error}`);
          }
        });

        dom.driveSaveBtn.addEventListener("click", async () => {
          try {
            if (!(await ensureDriveReady())) return;
            const folderId = await ensureDriveFolder();
            const fileName = buildTimestampedDriveFileName();
            const content = JSON.stringify(AppState.data, null, 2);
            if (GoogleDrive.gapiLoaded && window.gapi?.client?.drive) {
              try {
                const boundary = "-------314159265358979323846";
                const delimiter = `\r\n--${boundary}\r\n`;
                const closeDelimiter = `\r\n--${boundary}--`;
                const metadata = {
                  name: fileName,
                  mimeType: "application/json",
                  parents: [folderId],
                };
                const multipartBody =
                  `${delimiter}Content-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(metadata)}` +
                  `${delimiter}Content-Type: application/json\r\n\r\n${content}${closeDelimiter}`;

                const response = await gapi.client.request({
                  path: "/upload/drive/v3/files",
                  method: "POST",
                  params: { uploadType: "multipart" },
                  headers: {
                    "Content-Type": `multipart/related; boundary=${boundary}`,
                  },
                  body: multipartBody,
                });
                GoogleDrive.currentFileId = response.result?.id || null;
                alert("Salvato su Drive ✅");
                return;
              } catch (error) {
                console.warn("gapi upload fallito, uso REST:", error);
              }
            }
            GoogleDrive.currentFileId = await uploadJsonFallback(
              fileName,
              content,
              folderId
            );
            alert("Salvato su Drive (REST) ✅");
          } catch (error) {
            alert(`Errore salvataggio Drive: ${error.message || error}`);
          }
        });

        updateDriveUI();
        render();
      })();
    </script>
  </body>
</html>
