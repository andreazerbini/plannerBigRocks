<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kanban Covey – Tabs + Tabelle + Drive</title>
    <style>
      :root {
        --bg: #0b0f16;
        --panel: #121826;
        --muted: #9aa4b2;
        --text: #e6edf3;
        --accent: #5eead4;
        --card: #0f172a;
        --border: #263046;
        --warn: #f59e0b;
        --danger: #ef4444;
        --h-header: 56px;
        --h-tabs: 46px;
        --sticky-top: calc(var(--h-header) + var(--h-tabs));
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        color: var(--text);
        background: linear-gradient(120deg, #0b0f16, #0a1322 60%, #0b0f16);
      }

      header {
        position: sticky;
        top: 0;
        z-index: 20;
        display: flex;
        align-items: center;
        gap: 0.8rem;
        height: var(--h-header);
        padding: 1rem;
        border-bottom: 1px solid var(--border);
        background: rgba(11, 15, 22, 0.7);
        backdrop-filter: blur(8px);
      }

      h1 {
        margin: 0;
        font-size: 1.05rem;
        font-weight: 700;
        letter-spacing: 0.2px;
      }

      .tag {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 999px;
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-left: auto;
      }

      .sprint-strip-wrapper {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 0.5rem 0;
        width: 100%;
        max-width: 100%;
      }

      .sprint-strip {
        display: flex;
        align-items: stretch;
        justify-content: center;
        gap: 0.5rem;
        flex: 1 1 auto;
        min-width: 0;
      }

      .sprint-ellipsis {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0 0.25rem;
        font-size: 1.1rem;
        color: var(--muted);
      }

      .sprint-nav {
        width: 40px;
        height: 40px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: var(--panel);
        color: var(--muted);
        font-size: 1.1rem;
        cursor: pointer;
        transition: border-color 0.2s ease, color 0.2s ease;
      }

      .sprint-nav:hover:not(:disabled) {
        border-color: #33405e;
        color: var(--text);
      }

      .sprint-nav:disabled {
        opacity: 0.35;
        cursor: default;
      }

      .sprint-pill {
        min-width: 160px;
        padding: 0.5rem 0.75rem;
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        background: rgba(18, 24, 38, 0.7);
        color: var(--muted);
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
        transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease,
          box-shadow 0.2s ease;
        white-space: nowrap;
      }

      .sprint-pill .sprint-name {
        font-weight: 600;
        font-size: 0.85rem;
      }

      .sprint-pill .sprint-dates {
        font-size: 0.75rem;
        color: var(--muted);
        opacity: 0.8;
      }

      .sprint-pill.current {
        border-color: rgba(94, 234, 212, 0.75);
        background: linear-gradient(135deg, rgba(94, 234, 212, 0.25), rgba(14, 116, 144, 0.2));
        color: #e6fffb;
        box-shadow: 0 0 0 1px rgba(94, 234, 212, 0.2);
      }

      .sprint-pill.current .sprint-dates {
        color: #ccfbf1;
      }

      .sprint-pill.selected {
        border-color: #38bdf8;
        box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.35);
      }

      .sprint-pill.selected:not(.current) {
        background: linear-gradient(135deg, rgba(18, 24, 38, 0.95), rgba(30, 41, 59, 0.95));
        color: var(--text);
      }

      .sprint-pill.current.selected {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(94, 234, 212, 0.45);
      }

      .sprint-details-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.75rem;
      }

      button,
      input,
      select,
      textarea {
        font: inherit;
      }

      button {
        padding: 0.55rem 0.75rem;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        background: var(--panel);
        cursor: pointer;
      }

      button:hover {
        border-color: #33405e;
      }

      button.primary {
        color: #061317;
        border-color: transparent;
        background: linear-gradient(135deg, #12b3a6, #6ee7d2);
      }

      button.primary:hover {
        filter: brightness(1.02);
      }

      button.danger {
        color: #2b100f;
        border-color: transparent;
        background: linear-gradient(135deg, #ef4444, #f59e0b);
      }

      .drawer {
        position: relative;
        border: 1px solid var(--border);
        border-radius: 0.9rem;
        background: rgba(18, 24, 38, 0.7);
        overflow: hidden;
        transition: box-shadow 0.2s ease, border-color 0.2s ease;
      }

      .drawer + .drawer {
        margin-top: 0.05rem;
      }

      .drawer:hover
      /** .drawer:focus-within **/
      {
        border-color: rgba(94, 234, 212, 0.45);
        box-shadow: 0 0 0 2px rgba(94, 234, 212, 0.25);
      }

      .drawer-toggle {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border: none;
        border-radius: 0;
        background: rgba(15, 23, 42, 0.6);
        color: var(--text);
        font-weight: 600;
        cursor: pointer;
        text-align: left;
      }

      .drawer-toggle:hover {
        border: none;
        background: rgba(15, 23, 42, 0.75);
      }

      .drawer-toggle:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .drawer-toggle-icon {
        font-size: 0.95rem;
        transition: transform 0.2s ease;
      }

      .drawer.open .drawer-toggle-icon {
        transform: rotate(180deg);
      }

      .drawer-content {
        display: none;
        padding: 0.9rem 1rem 1rem;
        gap: 0.75rem;
      }

      .drawer.open .drawer-content {
        display: grid;
      }

      nav.tabs {
        position: sticky;
        top: var(--h-header);
        z-index: 15;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        height: var(--h-tabs);
        padding: 0.6rem 1rem;
        border-bottom: 1px solid var(--border);
        background: rgba(11, 15, 22, 0.7);
        backdrop-filter: blur(8px);
      }

      .tab {
        padding: 0.45rem 0.75rem;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 0.65rem;
        cursor: pointer;
        background: transparent;
      }

      .tab.active {
        color: #061317;
        border-color: transparent;
        background: linear-gradient(135deg, #12b3a6, #6ee7d2);
      }

      main {
        display: grid;
        gap: 1rem;
        padding: 1rem;
      }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        background: rgba(18, 24, 38, 0.7);
        border: 1px solid var(--border);
        border-radius: 0.9rem;
        overflow: hidden;
      }

      thead th {
        /* position: sticky; */
        top: var(--sticky-top);
        z-index: 10;
        padding: 0.7rem 0.8rem;
        font-size: 0.85rem;
        text-align: left;
        white-space: nowrap;
        color: var(--muted);
        user-select: none;
        background: #121826;
        border-bottom: 1px solid var(--border);
      }

      th.sortable {
        cursor: pointer;
      }

      th.sortable::after {
        margin-left: 0.25rem;
        font-size: 0.7rem;
        opacity: 0.35;
        content: "▲▼";
      }

      th.sortable.asc::after {
        content: "▲";
        opacity: 0.85;
      }

      th.sortable.desc::after {
        content: "▼";
        opacity: 0.85;
      }

      tbody td {
        padding: 0.6rem 0.8rem;
        border-bottom: 1px solid #1b2436;
      }

      tbody tr:hover {
        background: #0f1628;
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .controls.filters {
        align-items: flex-end;
        gap: 0.75rem;
      }

      .filter-field {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        min-width: 140px;
        font-size: 0.75rem;
        color: var(--muted);
      }

      .filter-field input,
      .filter-field select {
        width: 100%;
      }

      input[type="text"],
      input[type="number"],
      input[type="date"],
      select,
      textarea {
        width: 100%;
        padding: 0.45rem 0.5rem;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        background: #0b1324;
      }

      textarea {
        min-height: 54px;
        resize: vertical;
      }

      .kanban {
        display: grid;
        grid-auto-flow: column;
        grid-auto-columns: minmax(260px, 1fr);
        gap: 1rem;
        overflow-x: auto;
        padding-bottom: 0.5rem;
      }

      .kanban-column {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 200px;
        padding: 0.9rem;
        border: 1px solid var(--border);
        border-radius: 0.9rem;
        background: rgba(18, 24, 38, 0.7);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .kanban-column.dragover {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px var(--accent);
      }

      .kanban-column-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        font-weight: 600;
      }

      .kanban-column-count {
        font-size: 0.8rem;
        color: var(--muted);
      }

      .kanban-column-body {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 48px;
      }

      .kanban-column-placeholder {
        margin: 0;
        padding: 1rem;
        font-size: 0.85rem;
        color: var(--muted);
        text-align: center;
        border: 1px dashed var(--border);
        border-radius: 0.8rem;
      }

      .kanban-card {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        padding: 0.8rem;
        border: 1px solid var(--border);
        border-radius: 0.85rem;
        background: var(--card);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        cursor: grab;
      }

      .kanban-card.dragging {
        opacity: 0.6;
      }

      .kanban-card:active {
        cursor: grabbing;
      }

      .kanban-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
      }

      .kanban-card-hierarchy {
        font-size: 0.75rem;
        color: var(--muted);
      }

      .kanban-card-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
      }

      .kanban-card .description {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .badge {
        display: inline-block;
        padding: 0.1rem 0.45rem;
        font-size: 0.7rem;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
      }

      .priority-chip {
        position: relative;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        min-width: 110px;
        padding: 0.25rem 0.45rem;
        border: 1px solid var(--border);
        border-radius: 0.6rem;
        background: rgba(15, 23, 42, 0.7);
        overflow: hidden;
      }

      .priority-chip::before {
        content: "";
        position: absolute;
        inset: 0;
        width: var(--fill, 0%);
        background: linear-gradient(90deg, #22c55e, #f97316, #ef4444);
        opacity: 0.25;
      }

      .priority-chip strong {
        position: relative;
        font-variant-numeric: tabular-nums;
      }

      .priority-chip small {
        position: relative;
        color: var(--muted);
      }

      .quadrant-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.2rem 0.5rem;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(18, 24, 38, 0.85);
        font-size: 0.75rem;
      }

      .quadrant-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.15);
      }

      .quadrant-q1 {
        background: #ef4444;
      }

      .quadrant-q2 {
        background: #22c55e;
      }

      .quadrant-q3 {
        background: #facc15;
      }

      .quadrant-q4 {
        background: #9ca3af;
      }

      .panel-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
        gap: 1rem;
        width: 100%;
      }

      .panel {
        position: relative;
        border: 1px solid var(--border);
        border-radius: 0.9rem;
        background: rgba(18, 24, 38, 0.8);
        padding: 0.75rem 0.75rem 1rem;
        min-height: 360px;
      }

      .panel.fullscreen {
        position: fixed;
        inset: 0.75rem;
        z-index: 30;
        width: auto;
        height: auto;
        max-height: calc(100vh - 1.5rem);
        max-width: none;
        overflow: auto;
      }

      .panel.fullscreen .quadrant-chart,
      .panel.fullscreen .burndown-chart {
        height: min(82vh, 820px);
      }

      .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        margin-bottom: 0.5rem;
      }

      .panel-actions {
        display: flex;
        gap: 0.35rem;
      }

      .quadrant-chart {
        position: relative;
        height: 320px;
        border: 1px dashed var(--border);
        border-radius: 0.75rem;
        background: rgba(11, 15, 22, 0.6);
        overflow: visible;
        padding: 12px;
        --axis-offset: -10px;
      }

      .quadrant-chart .quadrant-bg {
        position: absolute;
        border-radius: 0.65rem;
        pointer-events: none;
        z-index: 1;
      }

      .quadrant-chart .quadrant-bg.q1 {
        background: rgba(239, 68, 68, 0.06);
      }

      .quadrant-chart .quadrant-bg.q2 {
        background: rgba(34, 197, 94, 0.06);
      }

      .quadrant-chart .quadrant-bg.q3 {
        background: rgba(250, 204, 21, 0.07);
      }

      .quadrant-chart .quadrant-bg.q4 {
        background: rgba(156, 163, 175, 0.06);
      }

      .quadrant-chart .axis-line {
        position: absolute;
        background: rgba(255, 255, 255, 0.08);
        z-index: 3;
      }

      .quadrant-chart .axis-line.vertical {
        width: 2px;
        height: 100%;
        left: 50%;
        top: 0;
      }

      .quadrant-chart .axis-line.horizontal {
        height: 2px;
        width: 100%;
        top: 50%;
        left: 0;
      }

      .quadrant-chart .axis-label {
        position: absolute;
        font-size: 0.75rem;
        color: var(--muted);
        padding: 0.15rem 0.35rem;
        background: rgba(15, 23, 42, 0.75);
        border: 1px solid var(--border);
        border-radius: 0.45rem;
        z-index: 4;
      }

      .quadrant-chart .axis-value {
        position: absolute;
        font-size: 0.75rem;
        color: var(--muted);
        padding: 0.2rem 0.45rem;
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid var(--border);
        border-radius: 0.45rem;
        z-index: 4;
        white-space: nowrap;
      }

      .quadrant-chart .axis-value.importance {
        left: var(--axis-offset);
        transform: translate(0, -50%);
      }

      .quadrant-chart .axis-value.time {
        bottom: var(--axis-offset);
        transform: translate(-50%, 0);
      }

      .quadrant-chart .axis-label.importance-top {
        left: var(--axis-offset);
        top: var(--axis-offset);
      }

      .quadrant-chart .axis-label.importance-bottom {
        left: var(--axis-offset);
        bottom: var(--axis-offset);
      }

      .quadrant-chart .axis-label.time-left {
        bottom: var(--axis-offset);
        left: var(--axis-offset);
      }

      .quadrant-chart .axis-label.time-right {
        bottom: var(--axis-offset);
        right: var(--axis-offset);
      }

      .quadrant-chart .quadrant-point {
        position: absolute;
        transform: translate(-50%, -50%);
        border: 1px solid rgba(0, 0, 0, 0.25);
        width: 14px;
        height: 14px;
        border-radius: 50%;
        cursor: pointer;
        z-index: 5;
      }

      .quadrant-chart .chart-tooltip {
        position: absolute;
        pointer-events: none;
        padding: 0.35rem 0.45rem;
        font-size: 0.8rem;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        white-space: normal;
        transform: translate(-50%, -120%);
        opacity: 0;
        transition: opacity 0.1s ease;
        z-index: 6;
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
        align-items: center;
        text-align: center;
      }

      .chart-tooltip .tooltip-title {
        font-weight: 700;
      }

      .chart-tooltip .tooltip-body {
        color: var(--muted);
      }

      .burndown-chart {
        position: relative;
        height: 320px;
        border: 1px dashed var(--border);
        border-radius: 0.75rem;
        background: rgba(11, 15, 22, 0.6);
        padding: 0.75rem 0.75rem 2.1rem;
        --burndown-padding-pct: 40%;
      }

      .burndown-plot-area {
        position: relative;
        width: 100%;
        height: 100%;
      }

      .burndown-chart svg {
        width: 100%;
        height: 100%;
        display: block;
      }

      .burndown-grid-line {
        stroke: rgba(148, 163, 184, 0.15);
        stroke-width: 0.5;
        shape-rendering: crispEdges;
      }

      .burndown-axis {
        stroke: rgba(148, 163, 184, 0.4);
        stroke-width: 0.8;
      }

      .burndown-path {
        fill: none;
        stroke-width: 2.5;
      }

      .burndown-path.actual {
        stroke: #22c55e;
      }

      .burndown-path.ideal {
        stroke: #38bdf8;
        stroke-dasharray: 4 4;
      }

      .burndown-point {
        fill: #0b0f16;
        stroke: #22c55e;
        stroke-width: 1.4;
      }

      .burndown-axis-text {
        fill: var(--muted);
        font-size: 3.15px;
        font-family: inherit;
        letter-spacing: 0.1px;
        pointer-events: none;
      }

      .burndown-axis-text.y-label {
        text-anchor: end;
        dominant-baseline: middle;
      }

      .burndown-axis-text.x-label {
        text-anchor: middle;
        dominant-baseline: hanging;
      }

      .burndown-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 0.65rem;
        align-items: center;
        margin-top: 0.6rem;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        background: rgba(15, 23, 42, 0.7);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0.25rem 0.6rem;
      }

      .legend-swatch {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        border: 2px solid rgba(0, 0, 0, 0.35);
      }

      .burndown-summary {
        margin-top: 0.35rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .burndown-summary .pill {
        background: rgba(15, 23, 42, 0.8);
        border: 1px solid var(--border);
        border-radius: 0.6rem;
        padding: 0.35rem 0.55rem;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .title {
        font-weight: 700;
      }

      .task-state-select {
        --state-color: var(--border);
        border: 2px solid var(--state-color);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .task-state-select:focus {
        box-shadow: 0 0 0 2px rgba(94, 234, 212, 0.35);
      }

      .footer {
        padding: 1rem;
        font-size: 0.85rem;
        color: var(--muted);
        border-top: 1px solid var(--border);
      }

      @media (max-width: 700px) {
        header {
          align-items: flex-start;
        }

        .kanban {
          grid-auto-columns: minmax(220px, 1fr);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Kanban Covey</h1>
      <span class="tag">Ruoli → LT → BT → Attività</span>
      <div class="actions">
        <button id="export">Esporta JSON</button>
        <button id="importBtn">Importa JSON</button>
        <button id="saveFile">Salva su file</button>
        <button id="openFile">Apri file</button>
        <button id="gSignIn">Connetti Google</button>
        <button id="driveOpen" disabled>Apri da Drive</button>
        <button id="driveSave" disabled>Salva su Drive</button>
        <span id="driveStatus" class="tag" title="Stato Google Drive">Drive: offline</span>
        <button class="danger" id="clear">Azzera</button>
      </div>
    </header>

    <nav id="tabs" class="tabs"></nav>
    <main id="view"></main>

    <footer class="footer">
      <strong>Salvataggio locale:</strong> automatico in <code>localStorage</code>.
      Puoi anche <em>Esportare/Importare</em> JSON.
      Su browser Chromium/Edge puoi usare "Salva su file" e "Apri file" (File System Access API).
      <br />
      Opzionale: connessione a <strong>Google Drive</strong> (inserisci <em>Client ID</em> e <em>API Key</em>) per aprire/salvare il JSON.
    </footer>

    <input id="filePicker" type="file" accept="application/json" hidden />
    <input
      id="taskCsvPicker"
      type="file"
      accept="text/csv,.csv"
      hidden
    />

    <script>
      (() => {
        "use strict";

        // =============================================================
        // Costanti e configurazione di base
        // =============================================================
        const STORAGE_KEYS = Object.freeze({
          STATE: "covey_v2_domain_model",
          GD_CLIENT_ID: "covey_gd_client_id",
          GD_API_KEY: "covey_gd_api_key",
          GD_FOLDER_ID: "covey_gd_folder_id",
        });

        const DRIVE_FOLDER_NAME = "Kanban_Covey_BigRocks";
        const DRIVE_FILE_PREFIX = "kanban_covey_bigrocks";

        const DEFAULT_FILE_NAME = "kanban-covey.json";
        const GOOGLE_DISCOVERY_DOCS = [
          "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest",
        ];
        const GOOGLE_SCOPE = "https://www.googleapis.com/auth/drive.file";

        const TASK_STATE_IDS = Object.freeze({
          TO_REFINE: "to_refine",
          TO_DO: "to_do",
          IN_PROGRESS: "in_progress",
          PAUSED: "paused",
          DONE: "done",
          REJECTED: "rejected",
        });

        const TASK_STATES = [
          {
            id: TASK_STATE_IDS.TO_REFINE,
            label: "Da pensare meglio",
            color: "#9ca3af",
          },
          {
            id: TASK_STATE_IDS.TO_DO,
            label: "Da fare",
            color: "#38bdf8",
          },
          {
            id: TASK_STATE_IDS.IN_PROGRESS,
            label: "In evoluzione",
            color: "#facc15",
          },
          {
            id: TASK_STATE_IDS.PAUSED,
            label: "Paused",
            color: "#f97316",
          },
          {
            id: TASK_STATE_IDS.DONE,
            label: "Fatto",
            color: "#22c55e",
          },
          {
            id: TASK_STATE_IDS.REJECTED,
            label: "Rejected",
            color: "#ef4444",
          },
        ];

        const CLOSING_TASK_STATES = new Set([
          TASK_STATE_IDS.DONE,
          TASK_STATE_IDS.REJECTED,
        ]);

        function isoToday() {
          return new Date().toISOString().slice(0, 10);
        }

        function isoAddDays(days, fromDate) {
          const base = fromDate ? new Date(fromDate) : new Date();
          if (Number.isFinite(days)) {
            base.setDate(base.getDate() + Number(days));
          }
          return base.toISOString().slice(0, 10);
        }

        function sanitizeIsoDate(value) {
          const trimmed = typeof value === "string" ? value.trim() : "";
          return /^\d{4}-\d{2}-\d{2}$/.test(trimmed) ? trimmed : null;
        }

        function promptForIsoDate(message, initialValue) {
          const defaultValue = sanitizeIsoDate(initialValue) || isoToday();
          const response = window.prompt(message, defaultValue);
          if (response == null) return null;
          const trimmed = response.trim();
          if (!trimmed) return "";
          if (!/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
            alert("Formato data non valido. Usa YYYY-MM-DD.");
            return promptForIsoDate(message, defaultValue);
          }
          return trimmed;
        }

        const DEFAULT_TASK_STATE = TASK_STATE_IDS.TO_DO;
        const TASK_STATE_BY_ID = new Map(
          TASK_STATES.map((state) => [state.id, state])
        );

        const tabs = [
          { id: "roles", label: "Ruoli" },
          { id: "lt", label: "Obiettivi a lungo termine" },
          { id: "st", label: "Obiettivi a breve termine" },
          { id: "tasks", label: "Attività" },
          { id: "dash", label: "Dashboard" },
          { id: "stats", label: "Statistiche" },
        ];

        const PRIORITY_CONFIG = Object.freeze({
          MIN_PRIORITY: 1,
          MAX_PRIORITY: 5,
          BALANCE_TIME_IMPORTANCE: 0.65,
          QUADRANT_MODE: "dynamic", // "fixed" oppure "dynamic"
        });

        const TaskMetricsCache = {
          dirty: true,
          map: new Map(),
          stats: {
            priorityMin: PRIORITY_CONFIG.MIN_PRIORITY,
            priorityMax: PRIORITY_CONFIG.MAX_PRIORITY,
          },
        };

        function markTaskMetricsDirty() {
          TaskMetricsCache.dirty = true;
        }

        const TableSortState = new Map();

        // =============================================================
        // Stato applicativo e persistence layer
        // =============================================================
        const AppState = {
          data: loadState(),
          currentFileHandle: null,
          persist() {
            markTaskMetricsDirty();
            localStorage.setItem(
              STORAGE_KEYS.STATE,
              JSON.stringify(this.data)
            );
          },
          replace(nextState) {
            normalizeDomain(nextState);
            this.data = nextState;
            updateSelectedSprint(
              this.data.currentSprintId || selectedSprintId,
              { rerenderShortTerm: false }
            );
            this.persist();
          },
          nextId() {
            return String(this.data.nextId++);
          },
        };

        function defaultState() {
          return { nextId: 1, roles: [], sprints: [], currentSprintId: null };
        }

        function loadState() {
          try {
            const raw = localStorage.getItem(STORAGE_KEYS.STATE);
            if (!raw) return seedState();
            const parsed = JSON.parse(raw);
            if (!validate(parsed)) return seedState();
            normalizeDomain(parsed);
            return parsed;
          } catch (err) {
            console.warn("Impossibile leggere lo stato salvato, uso seed.", err);
            return seedState();
          }
        }

        function seedState() {
          const seeded = defaultState();
          const today = () => new Date().toISOString().slice(0, 10);
          const datePlus = (days) => {
            const date = new Date();
            date.setDate(date.getDate() + days);
            return date.toISOString().slice(0, 10);
          };
          const nextId = () => String(seeded.nextId++);

          const sprint = {
            id: nextId(),
            name: "Sprint iniziale",
            start: today(),
            end: datePlus(14),
            st_goal_ids: [],
          };

          const role = {
            id: nextId(),
            title: "Team Leader",
            importance: 3,
            lt_goals: [],
          };
          const longTerm = {
            id: nextId(),
            title: "Introdurre ML nel prodotto",
            description: "Roadmap ML (RAG, valutazione, privacy)",
            importance: 5,
            due: datePlus(120),
            achieved_on: null,
            st_goals: [],
          };
          const shortTerm = {
            id: nextId(),
            title: "PoC RAG su documentale",
            description: "Pipeline base eval + feedback",
            importance: null,
            due: null,
            achieved_on: null,
            sprint_id: sprint.id,
            tasks: [],
          };
          const task = {
            id: nextId(),
            title: "Progettazione schema vector DB",
            description: "Definire spazio embedding e chunking",
            importance: 4,
            due: datePlus(30),
            state: TASK_STATE_IDS.TO_DO,
            closed_on: null,
            estimate_hours: 6,
          };

          shortTerm.tasks.push(task);
          longTerm.st_goals.push(shortTerm);
          role.lt_goals.push(longTerm);
          sprint.st_goal_ids.push(shortTerm.id);
          seeded.roles.push(role);
          seeded.sprints.push(sprint);
          seeded.currentSprintId = sprint.id;
          normalizeDomain(seeded);
          return seeded;
        }

        function validate(candidate) {
          return (
            candidate &&
            typeof candidate === "object" &&
            Array.isArray(candidate.roles) &&
            "nextId" in candidate
          );
        }

        function getTaskStateId(stateId) {
          return TASK_STATE_BY_ID.has(stateId) ? stateId : DEFAULT_TASK_STATE;
        }

        function getTaskStateConfig(stateId) {
          return TASK_STATE_BY_ID.get(getTaskStateId(stateId));
        }

        function normalizeTask(task) {
          if (!task || typeof task !== "object") return;
          task.state = getTaskStateId(task.state);
          task.closed_on = sanitizeIsoDate(task.closed_on);
          task.estimate_hours = toHoursOrNull(task.estimate_hours);
        }

        function normalizeDomain(root) {
          if (!root || typeof root !== "object") return;

          const numericNextId = Number(root.nextId);
          root.nextId = Number.isFinite(numericNextId) ? numericNextId : 1;
          const allocateId = () => String(root.nextId++);

          if (!Array.isArray(root.roles)) {
            root.roles = [];
          }
          if (!Array.isArray(root.sprints)) {
            root.sprints = [];
          }

          const sprintById = new Map();
          root.sprints = root.sprints.map((sprint, index) => {
            const id = sprint?.id != null ? String(sprint.id) : allocateId();
            const normalized = {
              id,
              name: sprint?.name || `Sprint ${index + 1}`,
              start: sanitizeIsoDate(sprint?.start),
              end: sanitizeIsoDate(sprint?.end),
              st_goal_ids: Array.isArray(sprint?.st_goal_ids)
                ? sprint.st_goal_ids.map((value) => String(value))
                : [],
            };
            sprintById.set(id, normalized);
            return normalized;
          });

          if (!root.sprints.length) {
            const id = allocateId();
            const defaultSprint = {
              id,
              name: "Sprint iniziale",
              start: isoToday(),
              end: isoAddDays(14),
              st_goal_ids: [],
            };
            root.sprints.push(defaultSprint);
            sprintById.set(id, defaultSprint);
          }

          if (root.currentSprintId != null) {
            root.currentSprintId = String(root.currentSprintId);
          }
          if (!root.currentSprintId || !sprintById.has(root.currentSprintId)) {
            root.currentSprintId = root.sprints[0]?.id || null;
          }

          const existingShortTerms = new Set();

          root.roles.forEach((role) => {
            role.id = role?.id != null ? String(role.id) : allocateId();
            role.lt_goals = Array.isArray(role.lt_goals) ? role.lt_goals : [];
            role.lt_goals.forEach((lt) => {
              lt.id = lt?.id != null ? String(lt.id) : allocateId();
              lt.st_goals = Array.isArray(lt.st_goals) ? lt.st_goals : [];
              lt.achieved_on = sanitizeIsoDate(lt.achieved_on);
              lt.st_goals.forEach((st) => {
                st.id = st?.id != null ? String(st.id) : allocateId();
                st.tasks = Array.isArray(st.tasks) ? st.tasks : [];
                st.achieved_on = sanitizeIsoDate(st.achieved_on);
                if (st.sprint_id != null) {
                  st.sprint_id = String(st.sprint_id);
                }
                if (!st.sprint_id || !sprintById.has(st.sprint_id)) {
                  st.sprint_id = root.currentSprintId;
                }
                if (st.sprint_id && sprintById.has(st.sprint_id)) {
                  const sprint = sprintById.get(st.sprint_id);
                  if (!Array.isArray(sprint.st_goal_ids)) {
                    sprint.st_goal_ids = [];
                  }
                  if (!sprint.st_goal_ids.includes(st.id)) {
                    sprint.st_goal_ids.push(st.id);
                  }
                }
                existingShortTerms.add(st.id);
                st.tasks.forEach(normalizeTask);
              });
            });
          });

          root.sprints.forEach((sprint) => {
            if (!Array.isArray(sprint.st_goal_ids)) {
              sprint.st_goal_ids = [];
            }
            const unique = [];
            const seen = new Set();
            sprint.st_goal_ids
              .map((value) => String(value))
              .forEach((id) => {
                if (!existingShortTerms.has(id)) return;
                if (seen.has(id)) return;
                seen.add(id);
                unique.push(id);
              });
            sprint.st_goal_ids = unique;
          });
        }

        function findTaskRef({ roleId, ltId, stId, taskId }) {
          const role = AppState.data.roles.find((candidate) => candidate.id === roleId);
          if (!role) return null;
          const lt = role.lt_goals.find((candidate) => candidate.id === ltId);
          if (!lt) return null;
          const st = lt.st_goals.find((candidate) => candidate.id === stId);
          if (!st) return null;
          const task = st.tasks.find((candidate) => candidate.id === taskId);
          if (!task) return null;
          return { role, lt, st, task };
        }

        // =============================================================
        // Utilità di formattazione e coercizione
        // =============================================================
        const DateUtils = {
          today: () => new Date().toISOString().slice(0, 10),
          addDays(days) {
            const date = new Date();
            date.setDate(date.getDate() + days);
            return date.toISOString().slice(0, 10);
          },
        };

          function toImportance(value, fallback = 1) {
              const parsed = parseInt(value, 10);
              if (Number.isNaN(parsed)) return fallback;
              return Math.max(1, parsed); // ← niente limite superiore
          }

        function toImportanceOrNull(value) {
          if (value == null || value === "") return null;
          return toImportance(value, 1);
        }

        function toHoursOrNull(value) {
          if (value == null) return null;
          if (typeof value === "number") {
            if (!Number.isFinite(value)) return null;
            return Math.max(0, Math.round(value * 100) / 100);
          }
          const normalized = String(value).trim().replace(",", ".");
          if (!normalized) return null;
          const parsed = Number.parseFloat(normalized);
          if (!Number.isFinite(parsed)) return null;
          return Math.max(0, Math.round(parsed * 100) / 100);
        }

        function formatHours(value) {
          if (value == null) return "-";
          const rounded = Math.round(value * 100) / 100;
          const hasDecimals = Math.abs(rounded % 1) > 1e-6;
          return rounded.toLocaleString("it-IT", {
            minimumFractionDigits: hasDecimals ? 1 : 0,
            maximumFractionDigits: 2,
          });
        }

        function serializeHours(value) {
          if (value == null) return "";
          const rounded = Math.round(value * 100) / 100;
          return rounded.toString();
        }

        function formatSprintRange(sprint) {
          if (!sprint) return "—";
          const start = sprint.start || "—";
          const end = sprint.end || "—";
          return `${start} → ${end}`;
        }

        function ensureCurrentSprintId() {
          if (!Array.isArray(AppState.data.sprints)) {
            AppState.data.sprints = [];
          }
          let created = false;
          if (!AppState.data.sprints.length) {
            const newSprint = createSprint(
              `Sprint ${AppState.data.sprints.length + 1}`,
              DateUtils.today(),
              DateUtils.addDays(14)
            );
            AppState.data.sprints.push(newSprint);
            AppState.data.currentSprintId = newSprint.id;
            created = true;
          }
          if (
            !AppState.data.currentSprintId ||
            !AppState.data.sprints.some(
              (sprint) => sprint.id === AppState.data.currentSprintId
            )
          ) {
            AppState.data.currentSprintId =
              AppState.data.sprints[0]?.id || null;
            created = true;
          }
          return { id: AppState.data.currentSprintId, created };
        }

        function detachShortTermFromSprint(shortTerm) {
          if (!shortTerm || !shortTerm.sprint_id) return;
          const sprints = AppState.data.sprints || [];
          const sprint = sprints.find(
            (candidate) => candidate.id === shortTerm.sprint_id
          );
          if (sprint && Array.isArray(sprint.st_goal_ids)) {
            sprint.st_goal_ids = sprint.st_goal_ids.filter(
              (id) => id !== shortTerm.id
            );
          }
          shortTerm.sprint_id = null;
        }

        function attachShortTermToSprint(shortTerm, sprintId) {
          if (!shortTerm) return;
          const normalizedId = sprintId != null ? String(sprintId) : null;
          if (!normalizedId) {
            detachShortTermFromSprint(shortTerm);
            return;
          }
          if (shortTerm.sprint_id && shortTerm.sprint_id !== normalizedId) {
            detachShortTermFromSprint(shortTerm);
          }
          const sprint = (AppState.data.sprints || []).find(
            (candidate) => candidate.id === normalizedId
          );
          if (!sprint) return;
          shortTerm.sprint_id = normalizedId;
          if (!Array.isArray(sprint.st_goal_ids)) {
            sprint.st_goal_ids = [];
          }
          if (!sprint.st_goal_ids.includes(shortTerm.id)) {
            sprint.st_goal_ids.push(shortTerm.id);
          }
        }

        function applyTaskStateChange(task, nextStateId) {
          if (!task) return false;
          const previousState = getTaskStateId(task.state);
          const normalizedNext = getTaskStateId(nextStateId);
          if (previousState === normalizedNext) return true;

          if (CLOSING_TASK_STATES.has(normalizedNext)) {
            const value = promptForIsoDate(
              "Data effettiva di chiusura (YYYY-MM-DD)",
              task.closed_on || isoToday()
            );
            if (value === null) {
              return false;
            }
            task.closed_on = value ? value : null;
          } else if (CLOSING_TASK_STATES.has(previousState)) {
            task.closed_on = null;
          }

          task.state = normalizedNext;
          normalizeTask(task);
          return true;
        }

        // =============================================================
        // Ereditarietà di importanza/scadenza
        // =============================================================
        function effectiveImportance(node, parentImportance) {
          return node.importance != null
            ? toImportance(node.importance, 1)
            : parentImportance;
        }

        function effectiveDueDate(node, parentDueDate) {
          return node.due || parentDueDate || null;
        }

        function getSprintByIdMap() {
          const map = new Map();
          (AppState.data.sprints || []).forEach((sprint) => {
            if (sprint?.id != null) {
              map.set(String(sprint.id), sprint);
            }
          });
          return map;
        }

        function resolveTaskDueDate(
          lt,
          st,
          task,
          sprintById = getSprintByIdMap(),
          fallbackSprintId = null
        ) {
          if (task?.due) return task.due;
          if (st?.due) return st.due;
          if (lt?.due) return lt.due;
          const fallbackId =
            fallbackSprintId ??
            (typeof selectedSprintId !== "undefined" ? selectedSprintId : null) ??
            AppState.data.currentSprintId ??
            null;
          const sprint =
            sprintById.get(st?.sprint_id) ||
            (fallbackId ? sprintById.get(fallbackId) : null);
          return sprint?.end || null;
        }

        function clampChildToParent(child, parent) {
          const parentImportance = effectiveImportance(parent, 9999999);
          const parentDue = parent.due || null;

          if (
            child.importance != null &&
            child.importance > parentImportance
          ) {
            child.importance = parentImportance;
          }

          if (parentDue && child.due && child.due > parentDue) {
            child.due = parentDue;
          }
        }

        // =============================================================
        // Calcolo Priority e Quadrante (con cache)
        // =============================================================
        function resolveTaskImportance(lt, st, task) {
          const ltImportance = toImportance(lt.importance, 1);
          const stImportance =
            st.importance != null ? toImportance(st.importance, ltImportance) : ltImportance;
          return task.importance != null
            ? toImportance(task.importance, stImportance)
            : stImportance;
        }

        function computeDaysRemaining(targetDate, today = new Date()) {
          if (!targetDate) return 0;
          const todayStart = new Date(today);
          todayStart.setHours(0, 0, 0, 0);
          const dueDate = new Date(targetDate);
          if (Number.isNaN(dueDate.getTime())) return 0;
          const diff = Math.floor((dueDate - todayStart) / (1000 * 60 * 60 * 24));
          return Math.max(0, diff);
        }

        function buildPriorityContext(dayValues, importanceValues, config = PRIORITY_CONFIG) {
          if (!dayValues.length || !importanceValues.length) return null;

          const minDays = Math.min(...dayValues);
          const maxDays = Math.max(...dayValues);
          const minImp = Math.min(...importanceValues);
          const maxImp = Math.max(...importanceValues);

          const rangeDays = Math.max(1, maxDays - minDays);
          const rangeImp = Math.max(1, maxImp - minImp);

          const timePriorities = dayValues.map(
            (value) =>
              ((value - minDays) *
                (config.MIN_PRIORITY - config.MAX_PRIORITY)) /
                rangeDays +
              config.MAX_PRIORITY
          );

          const impPriorities = importanceValues.map(
            (value) =>
              ((value - minImp) *
                (config.MAX_PRIORITY - config.MIN_PRIORITY)) /
                rangeImp +
              config.MIN_PRIORITY
          );

          const stats = {
            minTimePrio: Math.min(...timePriorities),
            maxTimePrio: Math.max(...timePriorities),
            avgTimePrio:
              timePriorities.reduce((sum, value) => sum + value, 0) /
              timePriorities.length,
            minImpPrio: Math.min(...impPriorities),
            maxImpPrio: Math.max(...impPriorities),
            avgImpPrio:
              impPriorities.reduce((sum, value) => sum + value, 0) /
              impPriorities.length,
          };

          const useDynamic = config.QUADRANT_MODE !== "fixed";
          const timeThreshold = useDynamic
            ? stats.avgTimePrio
            : (stats.maxTimePrio - stats.minTimePrio) / 2;
          const impThreshold = useDynamic
            ? stats.avgImpPrio
            : (stats.maxImpPrio - stats.minImpPrio) / 2;

          return {
            timePriorities,
            impPriorities,
            timeThreshold,
            impThreshold,
            priorityRange: Math.max(
              1e-3,
              config.MAX_PRIORITY - config.MIN_PRIORITY
            ),
          };
        }

        function deriveQuadrantFromPriorities(
          timePriority,
          importancePriority,
          { timeThreshold, impThreshold }
        ) {
          const timeQuadrant = timePriority - timeThreshold > 0 ? "TH" : "TL";
          const importanceQuadrant =
            importancePriority - impThreshold > 0 ? "IH" : "IL";

          const quadrant =
            importanceQuadrant === "IL"
              ? timeQuadrant === "TH"
                ? "Q3"
                : "Q4"
              : timeQuadrant === "TH"
              ? "Q1"
              : "Q2";

          return { quadrant, timeQuadrant, importanceQuadrant };
        }

        function computeTaskMetricsCache() {
          if (!TaskMetricsCache.dirty) return;

          const sprintFilter = selectedSprintId || AppState.data.currentSprintId || null;
          const allRefs = getAllTaskRefs();
          const refs = sprintFilter
            ? allRefs.filter(({ st }) => st.sprint_id === sprintFilter)
            : allRefs;
          TaskMetricsCache.map.clear();

          if (!refs.length) {
            TaskMetricsCache.stats = {
              priorityMin: PRIORITY_CONFIG.MIN_PRIORITY,
              priorityMax: PRIORITY_CONFIG.MAX_PRIORITY,
            };
            TaskMetricsCache.dirty = false;
            return;
          }

          const today = new Date();
          const dayValues = [];
          const importanceValues = [];
          const sprintById = getSprintByIdMap();
          const fallbackSprintId = selectedSprintId || AppState.data.currentSprintId || null;
          const refCalculations = [];

          refs.forEach(({ lt, st, task }) => {
            const due = resolveTaskDueDate(
              lt,
              st,
              task,
              sprintById,
              fallbackSprintId
            );
            const daysRemaining = computeDaysRemaining(due, today);
            const importanceValue = resolveTaskImportance(lt, st, task);
            dayValues.push(daysRemaining);
            importanceValues.push(importanceValue);
            refCalculations.push({ due, daysRemaining, importanceValue });
          });

          const context = buildPriorityContext(
            dayValues,
            importanceValues,
            PRIORITY_CONFIG
          );

          if (!context) {
            TaskMetricsCache.stats = {
              priorityMin: PRIORITY_CONFIG.MIN_PRIORITY,
              priorityMax: PRIORITY_CONFIG.MAX_PRIORITY,
            };
            TaskMetricsCache.dirty = false;
            return;
          }

          refs.forEach((ref, index) => {
            const { due, daysRemaining, importanceValue } =
              refCalculations[index] || {};
            const timePriority = context.timePriorities[index] ?? PRIORITY_CONFIG.MIN_PRIORITY;
            const importancePriority =
              context.impPriorities[index] ?? PRIORITY_CONFIG.MIN_PRIORITY;

            const { quadrant, timeQuadrant, importanceQuadrant } =
              deriveQuadrantFromPriorities(timePriority, importancePriority, context);

            const priorityRaw =
              timePriority * PRIORITY_CONFIG.BALANCE_TIME_IMPORTANCE +
              importancePriority * (1 - PRIORITY_CONFIG.BALANCE_TIME_IMPORTANCE);
            const priority = Math.round(priorityRaw * 100) / 100;

            const priorityPercent = Math.min(
              1,
              Math.max(
                0,
                (priority - PRIORITY_CONFIG.MIN_PRIORITY) / context.priorityRange
              )
            );

            const normalizedTime = Math.min(
              1,
              Math.max(
                0,
                (timePriority - PRIORITY_CONFIG.MIN_PRIORITY) / context.priorityRange
              )
            );

            const normalizedImportance = Math.min(
              1,
              Math.max(
                0,
                (importancePriority - PRIORITY_CONFIG.MIN_PRIORITY) /
                  context.priorityRange
              )
            );

            TaskMetricsCache.map.set(ref.task.id, {
              priority,
              quadrant,
              timeQuadrant,
              importanceQuadrant,
              priorityPercent,
              timePriority,
              importancePriority,
              normalizedTime,
              normalizedImportance,
              timeThreshold: context.timeThreshold,
              impThreshold: context.impThreshold,
              dueDate: due || null,
              daysRemaining,
            });

            logTaskMetricsCalculation(ref, {
              due,
              daysRemaining,
              importanceValue,
              timePriority,
              importancePriority,
              priority,
              priorityPercent,
              normalizedTime,
              normalizedImportance,
              timeQuadrant,
              importanceQuadrant,
              quadrant,
              thresholds: {
                time: context.timeThreshold,
                importance: context.impThreshold,
              },
            });
          });

          TaskMetricsCache.stats = {
            priorityMin: PRIORITY_CONFIG.MIN_PRIORITY,
            priorityMax: PRIORITY_CONFIG.MAX_PRIORITY,
            timeThreshold: context.timeThreshold,
            impThreshold: context.impThreshold,
          };
          TaskMetricsCache.dirty = false;
        }

        function logTaskMetricsCalculation(ref, details) {
          const title = ref.task.title || "(Senza titolo)";
          const header = `Calcolo priority/quadrante → Task ${ref.task.id} • ${title}`;
          console.groupCollapsed(header);
          console.log("Scadenza risolta:", details.due || "(nessuna)");
          console.log("Giorni restanti:", details.daysRemaining);
          console.log("Importanza effettiva:", details.importanceValue);
          console.log("Priority tempo:", details.timePriority);
          console.log("Priority importanza:", details.importancePriority);
          console.log("Soglia tempo (asse TH/TL):", details.thresholds.time);
          console.log("Soglia importanza (asse IH/IL):", details.thresholds.importance);
          console.log("Quadranti tempo/importanza:", details.timeQuadrant, details.importanceQuadrant);
          console.log("Quadrante finale:", details.quadrant);
          console.log("Priority pesata:", details.priority, "(percentuale barra:",
            `${Math.round(details.priorityPercent * 100)}%)`
          );
          console.log("Normalizzazioni grafico:", {
            tempo: `${Math.round(details.normalizedTime * 100)}% TH`,
            importanza: `${Math.round(details.normalizedImportance * 100)}% IH`,
          });
          console.groupEnd();
        }

        function getTaskMetrics(ref) {
          computeTaskMetricsCache();
          return TaskMetricsCache.map.get(ref.task.id) || null;
        }

        function runQuadrantUnitTests() {
          const dayValues = [0, 10, 20, 40];
          const importanceValues = [5, 2, 5, 2];
          const context = buildPriorityContext(
            dayValues,
            importanceValues,
            PRIORITY_CONFIG
          );
          if (!context) return;

          const quadrants = context.timePriorities.map((timePriority, index) => {
            const importancePriority = context.impPriorities[index];
            return deriveQuadrantFromPriorities(
              timePriority,
              importancePriority,
              context
            ).quadrant;
          });

          const expected = ["Q1", "Q3", "Q2", "Q4"];
          console.assert(
            expected.every((value, index) => value === quadrants[index]),
            `Quadrant dynamic mismatch: expected ${expected.join(", ")}, got ${quadrants.join(", ")}`
          );
        }

        runQuadrantUnitTests();

          function cascadeFromRole(role) {
              role.lt_goals.forEach((lt) => {
                  // LT non può superare il Ruolo
                  clampChildToParent(lt, role);

                  lt.st_goals.forEach((st) => {
                      clampChildToParent(st, lt);
                      st.tasks.forEach((task) =>
                          clampChildToParent(task, st.due ? st : lt)
                      );
                  });
              });
          }


        // =============================================================
        // UI references e gestione tab
        // =============================================================
        const dom = {
          tabs: document.getElementById("tabs"),
          view: document.getElementById("view"),
          filePicker: document.getElementById("filePicker"),
          taskCsvPicker: document.getElementById("taskCsvPicker"),
          exportBtn: document.getElementById("export"),
          importBtn: document.getElementById("importBtn"),
          saveFileBtn: document.getElementById("saveFile"),
          openFileBtn: document.getElementById("openFile"),
          clearBtn: document.getElementById("clear"),
          driveStatus: document.getElementById("driveStatus"),
          googleBtn: document.getElementById("gSignIn"),
          driveOpenBtn: document.getElementById("driveOpen"),
          driveSaveBtn: document.getElementById("driveSave"),
        };

        function requestTaskCsvImport() {
          if (!dom.taskCsvPicker) return;
          dom.taskCsvPicker.value = "";
          dom.taskCsvPicker.click();
        }

        dom.taskCsvPicker?.addEventListener("change", async (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          try {
            const text = await file.text();
            const imported = importTasksFromCsvContent(text);
            AppState.persist();
            render();
            alert(`Importate ${imported} attività da CSV ✅`);
          } catch (error) {
            alert(`Errore import CSV: ${error.message || error}`);
          } finally {
            dom.taskCsvPicker.value = "";
          }
        });

        let activeTab = "roles";
        const sprintDrawerOpenState = {
          st: true,
          tasks: false,
          dash: false,
        };

        const filtersDrawerOpenState = {
          tasks: true,
          dash: true,
          stats: true,
        };

        function getSprintDrawerOpenState(key, fallback) {
          if (!key) return fallback;
          if (!Object.prototype.hasOwnProperty.call(sprintDrawerOpenState, key)) {
            sprintDrawerOpenState[key] = fallback;
          }
          return sprintDrawerOpenState[key];
        }

        function setSprintDrawerOpenState(key, value) {
          if (!key) return;
          sprintDrawerOpenState[key] = Boolean(value);
        }

        function getFiltersDrawerOpenState(key, fallback) {
          if (!key) return fallback;
          if (
            !Object.prototype.hasOwnProperty.call(filtersDrawerOpenState, key)
          ) {
            filtersDrawerOpenState[key] = fallback;
          }
          return filtersDrawerOpenState[key];
        }

        function setFiltersDrawerOpenState(key, value) {
          if (!key) return;
          filtersDrawerOpenState[key] = Boolean(value);
        }

        let selectedSprintId = AppState.data.currentSprintId || null;

        function updateSelectedSprint(
          nextId,
          {
            rerenderShortTerm = false,
            rerenderTasks = true,
            rerenderStats = activeTab === "stats",
          } = {}
        ) {
          const normalized = nextId != null ? String(nextId) : null;
            if (normalized === selectedSprintId) {
              if (rerenderShortTerm) {
                render();
              }
              return;
            }
            selectedSprintId = normalized;
            markTaskMetricsDirty();
            if (rerenderTasks) {
              rerenderFilterViews();
            }
            if (rerenderShortTerm) {
              render();
            }
            if (rerenderStats) {
            render();
          }
        }

        function getSprintUiContext() {
          const ensured = ensureCurrentSprintId();
          if (ensured.created) {
            AppState.persist();
          }
          if (!selectedSprintId && ensured.id) {
            updateSelectedSprint(ensured.id, { rerenderTasks: false });
          }

          const sortedSprints = Array.isArray(AppState.data.sprints)
            ? AppState.data.sprints.slice()
            : [];
          sortedSprints.sort((a, b) => {
            const startA = a.start || "";
            const startB = b.start || "";
            if (startA && startB && startA !== startB) {
              return startA.localeCompare(startB);
            }
            return (a.name || "").localeCompare(b.name || "");
          });

          if (
            sortedSprints.length &&
            !sortedSprints.some((sprint) => sprint.id === selectedSprintId)
          ) {
            const fallbackId =
              AppState.data.currentSprintId || sortedSprints[0]?.id || null;
            if (fallbackId && fallbackId !== selectedSprintId) {
              updateSelectedSprint(fallbackId, { rerenderTasks: false });
            }
          }

          if (!selectedSprintId && sortedSprints[0]) {
            updateSelectedSprint(sortedSprints[0].id, { rerenderTasks: false });
          }

          const resolvedId = selectedSprintId;
          const selectedSprint =
            sortedSprints.find((sprint) => sprint.id === resolvedId) ||
            sortedSprints[0] ||
            null;

          const selectedIndex = selectedSprint
            ? sortedSprints.findIndex((sprint) => sprint.id === selectedSprint.id)
            : -1;
          const prevSprint =
            selectedIndex > 0 ? sortedSprints[selectedIndex - 1] : null;
          const nextSprint =
            selectedIndex >= 0 &&
            selectedIndex < sortedSprints.length - 1
              ? sortedSprints[selectedIndex + 1]
              : null;

          return {
            sortedSprints,
            selectedSprint,
            prevSprint,
            nextSprint,
          };
        }

        function createSprintDrawer(
          { sortedSprints, selectedSprint, prevSprint, nextSprint },
          {
            startOpen = false,
            label = "Gestione sprint",
            syncShortTerm = false,
            stateKey = null,
          } = {}
        ) {
          const drawer = document.createElement("section");
          drawer.className = "drawer sprint-drawer";
          const shouldStartOpen = stateKey
            ? getSprintDrawerOpenState(stateKey, startOpen)
            : startOpen;
          if (shouldStartOpen) {
            drawer.classList.add("open");
          }

          if (stateKey) {
            setSprintDrawerOpenState(stateKey, shouldStartOpen);
          }

          const toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "drawer-toggle";
          const toggleLabel = document.createElement("span");
          toggleLabel.textContent = label;
          const toggleIcon = document.createElement("span");
          toggleIcon.className = "drawer-toggle-icon";
          toggle.append(toggleLabel, toggleIcon);

          const syncToggleState = () => {
            const isOpen = drawer.classList.contains("open");
            toggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
            toggleIcon.textContent = isOpen ? "▴" : "▾";
          };

          toggle.addEventListener("click", () => {
            drawer.classList.toggle("open");
            if (stateKey) {
              setSprintDrawerOpenState(
                stateKey,
                drawer.classList.contains("open")
              );
            }
            syncToggleState();
          });

          drawer.appendChild(toggle);
          syncToggleState();

          const content = document.createElement("div");
          content.className = "drawer-content";

          const sprintStripWrapper = document.createElement("div");
          sprintStripWrapper.className = "sprint-strip-wrapper";
          const sprintStrip = document.createElement("div");
          sprintStrip.className = "sprint-strip";

          const prevBtn = button("←", "sprint-nav", () => {
            if (prevSprint) {
              updateSelectedSprint(prevSprint.id, {
                rerenderShortTerm: syncShortTerm,
              });
            }
          });
          prevBtn.disabled = !prevSprint;

          const nextBtn = button("→", "sprint-nav", () => {
            if (nextSprint) {
              updateSelectedSprint(nextSprint.id, {
                rerenderShortTerm: syncShortTerm,
              });
            }
          });
          nextBtn.disabled = !nextSprint;

          sprintStripWrapper.append(prevBtn, sprintStrip, nextBtn);

          if (sortedSprints.length) {
            const selectedIndex = selectedSprint
              ? sortedSprints.findIndex((s) => s.id === selectedSprint.id)
              : 0;
            const currentIndex = selectedIndex >= 0 ? selectedIndex : 0;
            const startIndex = Math.max(0, currentIndex - 3);
            const endIndex = Math.min(
              sortedSprints.length - 1,
              currentIndex + 3
            );
            const hasHiddenBefore = startIndex > 0;
            const hasHiddenAfter = endIndex < sortedSprints.length - 1;

            if (hasHiddenBefore) {
              const ellipsis = document.createElement("span");
              ellipsis.className = "sprint-ellipsis";
              ellipsis.textContent = "…";
              sprintStrip.appendChild(ellipsis);
            }

            for (let idx = startIndex; idx <= endIndex; idx += 1) {
              const sprint = sortedSprints[idx];
              const pill = document.createElement("button");
              pill.type = "button";
              pill.className = `sprint-pill${
                sprint.id === selectedSprintId ? " selected" : ""
              }${
                sprint.id === AppState.data.currentSprintId ? " current" : ""
              }`;
              const name = document.createElement("span");
              name.className = "sprint-name";
              name.textContent = sprint.name || "Sprint";
              const dates = document.createElement("span");
              dates.className = "sprint-dates";
              dates.textContent = formatSprintRange(sprint);
              pill.append(name, dates);
              pill.addEventListener("click", () => {
                updateSelectedSprint(sprint.id, {
                  rerenderShortTerm: syncShortTerm,
                });
              });
              sprintStrip.appendChild(pill);
            }

            if (hasHiddenAfter) {
              const ellipsis = document.createElement("span");
              ellipsis.className = "sprint-ellipsis";
              ellipsis.textContent = "…";
              sprintStrip.appendChild(ellipsis);
            }
          } else {
            const empty = document.createElement("span");
            empty.className = "sprint-ellipsis";
            empty.textContent = "Nessuno sprint";
            sprintStrip.appendChild(empty);
          }

          const sprintActions = document.createElement("div");
          sprintActions.className = "controls";
          sprintActions.append(
            button("+ Sprint", "primary", () => {
              const newSprint = createSprint(
                `Sprint ${AppState.data.sprints.length + 1}`,
                DateUtils.today(),
                DateUtils.addDays(14)
              );
              AppState.data.sprints.push(newSprint);
              AppState.data.currentSprintId = newSprint.id;
              updateSelectedSprint(newSprint.id, {
                rerenderShortTerm: syncShortTerm,
              });
              AppState.persist();
              render();
            })
          );

          if (
            selectedSprint &&
            AppState.data.currentSprintId !== selectedSprint.id
          ) {
            sprintActions.append(
              button("Imposta come corrente", "", () => {
                AppState.data.currentSprintId = selectedSprint.id;
                AppState.persist();
                render();
              })
            );
          }

          if (selectedSprint) {
            const deleteSprintBtn = button("Elimina sprint", "", () => {
              if (
                (selectedSprint.st_goal_ids || []).length &&
                !confirmDelete(
                  "Lo sprint contiene obiettivi BT. Svuotarlo prima di eliminarlo?"
                )
              ) {
                return;
              }
              if ((selectedSprint.st_goal_ids || []).length) {
                alert(
                  "Rimuovi gli obiettivi BT dallo sprint prima di eliminarlo."
                );
                return;
              }
              AppState.data.sprints = AppState.data.sprints.filter(
                (candidate) => candidate.id !== selectedSprint.id
              );
              if (AppState.data.currentSprintId === selectedSprint.id) {
                AppState.data.currentSprintId =
                  AppState.data.sprints[0]?.id || null;
              }
              updateSelectedSprint(
                AppState.data.currentSprintId ||
                  AppState.data.sprints[0]?.id ||
                  null,
                { rerenderShortTerm: syncShortTerm }
              );
              AppState.persist();
              render();
            });
            if ((selectedSprint.st_goal_ids || []).length) {
              deleteSprintBtn.disabled = true;
              deleteSprintBtn.title =
                "Sposta o elimina gli obiettivi BT prima di eliminare lo sprint.";
            }
            sprintActions.append(deleteSprintBtn);
          }

          const sprintDetails = document.createElement("div");
          sprintDetails.className = "sprint-details-grid";

          if (selectedSprint) {
            const nameControl = inputText(
              selectedSprint.name || "",
              "Nome sprint",
              (value) => {
                selectedSprint.name = value;
              }
            );
            nameControl.addEventListener("blur", () => {
              AppState.persist();
              render();
            });

            const startControl = inputDate(
              selectedSprint.start,
              (value) => {
                selectedSprint.start = value || null;
              },
              { readOnly: false }
            );
            startControl.addEventListener("blur", () => {
              AppState.persist();
              render();
            });

            const endControl = inputDate(
              selectedSprint.end,
              (value) => {
                selectedSprint.end = value || null;
              },
              { readOnly: false }
            );
            endControl.addEventListener("blur", () => {
              AppState.persist();
              render();
            });

            sprintDetails.append(
              labeledControl("Nome", nameControl),
              labeledControl("Inizio", startControl),
              labeledControl("Fine", endControl)
            );
          }

          content.append(sprintStripWrapper, sprintActions);
          if (selectedSprint) {
            content.append(sprintDetails);
          }

          drawer.appendChild(content);
          return drawer;
        }

        function render() {
          renderTabs();
          const renderer = tabRenderers[activeTab];
          if (renderer) renderer();
        }

        function renderTabs() {
          dom.tabs.innerHTML = "";
          tabs.forEach((tab) => {
            const element = document.createElement("button");
            element.className = `tab${activeTab === tab.id ? " active" : ""}`;
            element.textContent = tab.label;
            element.addEventListener("click", () => {
              activeTab = tab.id;
              render();
            });
            dom.tabs.appendChild(element);
          });
        }

        const tabRenderers = {
          roles: renderRoles,
          lt: renderLongTermGoals,
          st: renderShortTermGoals,
          tasks: renderTasks,
          dash: renderDashboard,
          stats: renderStatistics,
        };

        // =============================================================
        // Helper UI element factories
        // =============================================================
        function inputText(value, placeholder, onInput) {
          const input = document.createElement("input");
          input.type = "text";
          input.value = value || "";
          if (placeholder) input.placeholder = placeholder;
          if (onInput) {
            input.addEventListener("input", () => onInput(input.value));
          }
          return input;
        }

        function inputInteger(value, onInput) {
          const input = document.createElement("input");
          input.type = "number";
          input.min = "1";
          // input.max = "99999";
          input.step = "1";
          input.value = value ?? "";
          input.addEventListener("input", () => {
            onInput(input.value === "" ? null : toImportance(input.value));
          });
          return input;
        }

        function inputHours(value, onInput) {
          const input = document.createElement("input");
          input.type = "number";
          input.min = "0";
          input.step = "0.25";
          input.inputMode = "decimal";
          input.value = value ?? "";
          input.addEventListener("input", () => {
            onInput(input.value === "" ? null : toHoursOrNull(input.value));
          });
          input.addEventListener("blur", () => {
            const normalized = toHoursOrNull(input.value);
            if (normalized == null) {
              input.value = "";
              onInput(null);
            } else {
              input.value = normalized.toString();
              onInput(normalized);
            }
          });
          return input;
        }

          function inputDate(value, onInput, { readOnly = false } = {}) {
              const input = document.createElement("input");
              input.type = "date";
              input.value = value || "";

              // Solo se esplicitamente richiesto, blocca la digitazione
              if (readOnly) {
                  input.readOnly = true;
                  input.addEventListener("keydown", (e) => e.preventDefault());
              }

              // Apri il calendario automaticamente al focus
              input.addEventListener("focus", () => {
                  // Questo funziona sulla maggior parte dei browser moderni
                  try {
                      input.showPicker?.();
                  } catch (e) {
                      // Fallback silenzioso se non supportato
                  }
              });

              // Aggiorna lo stato quando cambia la data
              input.addEventListener("change", () => {
                  onInput(input.value || null);
              });

              // Anche su input per catturare la digitazione
              input.addEventListener("input", () => {
                  onInput(input.value || null);
              });

              return input;
          }

        function textArea(value, onInput) {
          const area = document.createElement("textarea");
          area.value = value || "";
          area.addEventListener("input", () => onInput(area.value));
          return area;
        }

        function button(label, className, onClick) {
          const btn = document.createElement("button");
          btn.textContent = label;
          if (className) btn.className = className;
          btn.addEventListener("click", onClick);
          return btn;
        }

        function labeledControl(labelText, control) {
          const wrapper = document.createElement("label");
          wrapper.style.display = "flex";
          wrapper.style.flexDirection = "column";
          wrapper.style.gap = "0.25rem";
          const caption = document.createElement("span");
          caption.textContent = labelText;
          caption.style.fontSize = "0.75rem";
          caption.style.color = "var(--muted)";
          wrapper.append(caption, control);
          return wrapper;
        }

        const TASK_CSV_FILE_NAME = "kanban-covey-tasks.csv";
        const TASK_CSV_HEADERS = Object.freeze([
          "Ruolo",
          "LT",
          "ST",
          "Titolo",
          "Descrizione",
          "Importanza",
          "Stima (ore)",
          "Scadenza",
          "Stato",
        ]);

        const TASK_CSV_COLUMN_ALIASES = Object.freeze({
          role: ["ruolo", "role"],
          lt: ["lt", "obiettivo lt", "lungo termine", "long term", "long-term"],
          st: [
            "st",
            "bt",
            "obiettivo bt",
            "breve termine",
            "short term",
            "short-term",
          ],
          title: ["titolo", "title"],
          description: ["descrizione", "description"],
          importance: ["importanza", "importance"],
          estimate: [
            "stima",
            "stima (ore)",
            "ore stima",
            "estimate",
            "estimated hours",
          ],
          due: ["scadenza", "due", "deadline", "data"],
          state: ["stato", "state"],
        });

        const TASK_CSV_COLUMN_LABELS = Object.freeze({
          role: "Ruolo",
          lt: "LT",
          st: "ST",
          title: "Titolo",
          description: "Descrizione",
          importance: "Importanza",
          estimate: "Stima (ore)",
          due: "Scadenza",
          state: "Stato",
        });

        const TaskFilters = {
          roleId: null,
          ltId: null,
          stId: null,
          importanceMin: null,
          importanceMax: null,
          dueFrom: null,
          dueTo: null,
          state: "all",
          search: "",
        };
        let taskSearchDraft = TaskFilters.search;

        function getAllTaskRefs() {
          const refs = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) =>
              lt.st_goals.forEach((st) =>
                st.tasks.forEach((task) => refs.push({ role, lt, st, task }))
              )
            )
          );
          return refs;
        }

        function getFilteredTaskRefs() {
          return getAllTaskRefs().filter(taskMatchesFilters);
        }

        function taskMatchesFilters(ref) {
          const sprintFilter =
            selectedSprintId || AppState.data.currentSprintId || null;
          if (sprintFilter && ref.st.sprint_id !== sprintFilter) {
            return false;
          }

          const {
            roleId,
            ltId,
            stId,
            importanceMin,
            importanceMax,
            dueFrom,
            dueTo,
            state,
            search,
          } = TaskFilters;
          if (roleId && ref.role.id !== roleId) {
            return false;
          }

          if (ltId && ref.lt.id !== ltId) {
            return false;
          }

          if (stId && ref.st.id !== stId) {
            return false;
          }
          const taskImportance =
            ref.task.importance != null
              ? toImportance(ref.task.importance, 1)
              : null;

          if (importanceMin != null) {
            if (taskImportance == null || taskImportance < importanceMin) {
              return false;
            }
          }

          if (importanceMax != null) {
            if (taskImportance == null || taskImportance > importanceMax) {
              return false;
            }
          }

          const taskState = ref.task.state || DEFAULT_TASK_STATE;
          if (state !== "all" && taskState !== state) {
            return false;
          }

          const dueTimestamp = parseDateToTimestamp(ref.task.due);
          const fromTimestamp = parseDateToTimestamp(dueFrom);
          if (fromTimestamp != null) {
            if (dueTimestamp == null || dueTimestamp < fromTimestamp) {
              return false;
            }
          }

          const toTimestamp = parseDateToTimestamp(dueTo);
          if (toTimestamp != null) {
            if (dueTimestamp == null || dueTimestamp > toTimestamp) {
              return false;
            }
          }

          const query = normalizeForComparison(search);
          if (query) {
            const haystack = normalizeForComparison(
              `${ref.task.title || ""} ${ref.task.description || ""}`
            );
            if (!haystack.includes(query)) {
              return false;
            }
          }

          return true;
        }

        function parseDateToTimestamp(value) {
          if (!value) return null;
          const parsed = Date.parse(`${value}T00:00:00Z`);
          return Number.isNaN(parsed) ? null : parsed;
        }

        function updateTaskFilters(patch) {
          let changed = false;
          Object.entries(patch).forEach(([key, value]) => {
            if (TaskFilters[key] !== value) {
              TaskFilters[key] = value;
              changed = true;
            }
          });
          if (!changed) return;
          if (Object.prototype.hasOwnProperty.call(patch, "search")) {
            taskSearchDraft = TaskFilters.search;
          }
          rerenderFilterViews();
        }

        function rerenderFilterViews() {
          if (activeTab === "tasks") {
            renderTasks();
          } else if (activeTab === "dash") {
            renderDashboard();
          } else if (activeTab === "stats") {
            renderStatistics();
          }
        }

        function createTaskFiltersBar({ onExport, onImport }) {
          const container = document.createElement("div");
          container.className = "controls filters";

          const roleSelect = document.createElement("select");
          {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "Tutti i ruoli";
            roleSelect.appendChild(option);
          }
          AppState.data.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = role.title || "—";
            roleSelect.appendChild(option);
          });
          roleSelect.value = TaskFilters.roleId || "";
          roleSelect.addEventListener("change", () => {
            const selectedRoleId = roleSelect.value || null;
            const patch = { roleId: selectedRoleId };
            if (TaskFilters.roleId !== selectedRoleId) {
              patch.ltId = null;
              patch.stId = null;
            }
            updateTaskFilters(patch);
          });

          const ltSelect = document.createElement("select");
          const stSelect = document.createElement("select");
          const ltMetaById = new Map();
          const stMetaById = new Map();

          function populateLtOptions() {
            ltMetaById.clear();
            ltSelect.innerHTML = "";
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "Tutti i LT";
            ltSelect.appendChild(option);
            AppState.data.roles.forEach((role) => {
              if (TaskFilters.roleId && role.id !== TaskFilters.roleId) return;
              role.lt_goals.forEach((lt) => {
                ltMetaById.set(lt.id, { roleId: role.id });
                const ltOption = document.createElement("option");
                ltOption.value = lt.id;
                ltOption.textContent = `${role.title || "—"} › ${lt.title || "—"}`;
                ltSelect.appendChild(ltOption);
              });
            });
            const selectedLt = TaskFilters.ltId;
            if (selectedLt && ltMetaById.has(selectedLt)) {
              ltSelect.value = selectedLt;
            } else {
              ltSelect.value = "";
            }
          }

          function populateStOptions() {
            stMetaById.clear();
            stSelect.innerHTML = "";
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "Tutti i BT";
            stSelect.appendChild(option);
            AppState.data.roles.forEach((role) => {
              if (TaskFilters.roleId && role.id !== TaskFilters.roleId) return;
              role.lt_goals.forEach((lt) => {
                if (TaskFilters.ltId && lt.id !== TaskFilters.ltId) return;
                lt.st_goals.forEach((st) => {
                  stMetaById.set(st.id, { roleId: role.id, ltId: lt.id });
                  const stOption = document.createElement("option");
                  stOption.value = st.id;
                  stOption.textContent = `${role.title || "—"} › ${lt.title || "—"} › ${
                    st.title || "—"
                  }`;
                  stSelect.appendChild(stOption);
                });
              });
            });
            const selectedSt = TaskFilters.stId;
            if (selectedSt && stMetaById.has(selectedSt)) {
              stSelect.value = selectedSt;
            } else {
              stSelect.value = "";
            }
          }

          populateLtOptions();
          populateStOptions();

          ltSelect.addEventListener("change", () => {
            const value = ltSelect.value || null;
            if (!value) {
              updateTaskFilters({ ltId: null, stId: null });
              return;
            }
            const meta = ltMetaById.get(value);
            const patch = { ltId: value, stId: null };
            if (meta && TaskFilters.roleId !== meta.roleId) {
              patch.roleId = meta.roleId;
            }
            updateTaskFilters(patch);
          });

          stSelect.addEventListener("change", () => {
            const value = stSelect.value || null;
            if (!value) {
              updateTaskFilters({ stId: null });
              return;
            }
            const meta = stMetaById.get(value);
            const patch = { stId: value };
            if (meta) {
              if (TaskFilters.ltId !== meta.ltId) {
                patch.ltId = meta.ltId;
              }
              if (TaskFilters.roleId !== meta.roleId) {
                patch.roleId = meta.roleId;
              }
            }
            updateTaskFilters(patch);
          });

          const importanceMinInput = document.createElement("input");
          importanceMinInput.type = "number";
          importanceMinInput.min = "1";
          importanceMinInput.placeholder = "≥";
          importanceMinInput.value =
            TaskFilters.importanceMin != null ? TaskFilters.importanceMin : "";
          importanceMinInput.addEventListener("change", () => {
            const value = importanceMinInput.value.trim();
            updateTaskFilters({
              importanceMin: value === "" ? null : toImportance(value, 1),
            });
          });

          const importanceMaxInput = document.createElement("input");
          importanceMaxInput.type = "number";
          importanceMaxInput.min = "1";
          importanceMaxInput.placeholder = "≤";
          importanceMaxInput.value =
            TaskFilters.importanceMax != null ? TaskFilters.importanceMax : "";
          importanceMaxInput.addEventListener("change", () => {
            const value = importanceMaxInput.value.trim();
            updateTaskFilters({
              importanceMax: value === "" ? null : toImportance(value, 1),
            });
          });

          const stateSelect = document.createElement("select");
          const stateOptions = [
            { value: "all", label: "Tutti" },
            ...TASK_STATES.map((state) => ({
              value: state.id,
              label: state.label,
            })),
          ];
          stateOptions.forEach((option) => {
            const el = document.createElement("option");
            el.value = option.value;
            el.textContent = option.label;
            stateSelect.appendChild(el);
          });
          stateSelect.value = TaskFilters.state;
          stateSelect.addEventListener("change", () =>
            updateTaskFilters({ state: stateSelect.value })
          );

          const dueFromInput = document.createElement("input");
          dueFromInput.type = "date";
          dueFromInput.value = TaskFilters.dueFrom || "";
          dueFromInput.addEventListener("change", () =>
            updateTaskFilters({ dueFrom: dueFromInput.value || null })
          );
          dueFromInput.addEventListener("input", () =>
            updateTaskFilters({ dueFrom: dueFromInput.value || null })
          );

          const dueToInput = document.createElement("input");
          dueToInput.type = "date";
          dueToInput.value = TaskFilters.dueTo || "";
          dueToInput.addEventListener("change", () =>
            updateTaskFilters({ dueTo: dueToInput.value || null })
          );
          dueToInput.addEventListener("input", () =>
            updateTaskFilters({ dueTo: dueToInput.value || null })
          );

          const searchInput = document.createElement("input");
          searchInput.type = "text";
          searchInput.placeholder = "Cerca titolo o descrizione…";
          searchInput.value = taskSearchDraft || "";
          searchInput.addEventListener("input", () => {
            taskSearchDraft = searchInput.value;
          });
          searchInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              updateTaskFilters({ search: taskSearchDraft });
            }
          });

          container.append(
            createFilterField("Ruolo", roleSelect),
            createFilterField("LT", ltSelect),
            createFilterField("BT", stSelect),
            createFilterField("Importanza da", importanceMinInput),
            createFilterField("Importanza a", importanceMaxInput),
            createFilterField("Scadenza da", dueFromInput),
            createFilterField("Scadenza a", dueToInput),
            createFilterField("Stato", stateSelect),
            createFilterField("Ricerca", searchInput),
            button("Esporta CSV", "", () => onExport?.()),
            button("Importa CSV", "", () => onImport?.())
          );

          return container;
        }

        function createFiltersDrawer({
          onExport,
          onImport,
          startOpen = true,
          stateKey = null,
        } = {}) {
          const drawer = document.createElement("section");
          drawer.className = "drawer filters-drawer";
          const shouldStartOpen = stateKey
            ? getFiltersDrawerOpenState(stateKey, startOpen)
            : startOpen;
          if (shouldStartOpen) {
            drawer.classList.add("open");
          }

          if (stateKey) {
            setFiltersDrawerOpenState(stateKey, shouldStartOpen);
          }

          const toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "drawer-toggle";
          const toggleLabel = document.createElement("span");
          toggleLabel.textContent = "Filtri e azioni";
          const toggleIcon = document.createElement("span");
          toggleIcon.className = "drawer-toggle-icon";
          toggle.append(toggleLabel, toggleIcon);

          const syncToggleState = () => {
            const isOpen = drawer.classList.contains("open");
            toggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
            toggleIcon.textContent = isOpen ? "▴" : "▾";
          };

          toggle.addEventListener("click", () => {
            drawer.classList.toggle("open");
            if (stateKey) {
              setFiltersDrawerOpenState(
                stateKey,
                drawer.classList.contains("open")
              );
            }
            syncToggleState();
          });

          drawer.appendChild(toggle);
          syncToggleState();

          const content = document.createElement("div");
          content.className = "drawer-content";
          content.appendChild(
            createTaskFiltersBar({ onExport: () => onExport?.(), onImport })
          );

          drawer.appendChild(content);
          return drawer;
        }

        function createFilterField(label, control) {
          const wrapper = document.createElement("label");
          wrapper.className = "filter-field";
          const span = document.createElement("span");
          span.textContent = label;
          wrapper.append(span, control);
          return wrapper;
        }

        function selectRole(selectedId) {
          const select = document.createElement("select");
          AppState.data.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = role.title;
            select.appendChild(option);
          });
          if (selectedId) select.value = selectedId;
          return select;
        }

        function selectLongTerm(roleId, selectedId) {
          const select = document.createElement("select");
          const role = AppState.data.roles.find((r) => r.id === roleId);
          (role?.lt_goals || []).forEach((goal) => {
            const option = document.createElement("option");
            option.value = goal.id;
            option.textContent = goal.title;
            select.appendChild(option);
          });
          if (selectedId) select.value = selectedId;
          return select;
        }

        function createTaskStateSelect(task) {
          const select = document.createElement("select");
          select.className = "task-state-select";
          TASK_STATES.forEach((state) => {
            const option = document.createElement("option");
            option.value = state.id;
            option.textContent = state.label;
            select.appendChild(option);
          });
          select.value = getTaskStateId(task.state);
          updateTaskStateSelectStyle(select);
          select.addEventListener("change", () => {
            const previous = getTaskStateId(task.state);
            const desired = select.value;
            if (!applyTaskStateChange(task, desired)) {
              select.value = previous;
              updateTaskStateSelectStyle(select);
              return;
            }
              select.value = getTaskStateId(task.state);
              updateTaskStateSelectStyle(select);
              AppState.persist();
              rerenderFilterViews();
            });
            return select;
          }

        function updateTaskStateSelectStyle(select) {
          const config = getTaskStateConfig(select.value);
          if (!config) return;
          select.style.setProperty("--state-color", config.color);
          select.style.borderColor = config.color;
          select.style.boxShadow = `0 0 0 1px ${config.color} inset`;
          select.title = config.label;
        }

        function createBadge(text) {
          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = text;
          return badge;
        }

        function createPriorityChip(metrics) {
          const container = document.createElement("span");
          container.className = "priority-chip";
          const percent = metrics?.priorityPercent ?? 0;
          container.style.setProperty("--fill", `${Math.round(percent * 100)}%`);

          const value = document.createElement("strong");
          value.textContent = metrics?.priority != null ? metrics.priority.toFixed(2) : "-";
          const label = document.createElement("small");
          label.textContent = "pri";

          container.append(value, label);
          return container;
        }

        function createQuadrantBadge(quadrant) {
          const badge = document.createElement("span");
          badge.className = "quadrant-badge";
          const dot = document.createElement("span");
          dot.className = `quadrant-dot quadrant-${(quadrant || "").toLowerCase()}`;
          const label = document.createElement("span");
          label.textContent = quadrant || "-";
          badge.append(dot, label);
          return badge;
        }

        function truncateText(value, max) {
          const text = (value || "").trim();
          if (!text) return "—";
          return text.length > max ? `${text.slice(0, max - 1)}…` : text;
        }

        function confirmDelete(message) {
          return window.confirm(message || "Sei sicuro? Questa azione è irreversibile.");
        }

        function makeTable(columns, rows, options = {}) {
          const sortStateKey =
            typeof options.sortKey === "string" && options.sortKey.trim()
              ? options.sortKey.trim()
              : null;
          const wrapper = document.createElement("div");
          wrapper.style.overflowX = "auto";

          const table = document.createElement("table");
          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");

          let sortIndex = -1;
          let sortDir = 1;

          if (sortStateKey && TableSortState.has(sortStateKey)) {
            const stored = TableSortState.get(sortStateKey);
            if (
              stored &&
              typeof stored.index === "number" &&
              stored.index >= 0 &&
              stored.index < columns.length &&
              (columns[stored.index]?.key || columns[stored.index]?.sort)
            ) {
              sortIndex = stored.index;
              sortDir = stored.dir === -1 ? -1 : 1;
            }
          }

          function defaultComparator(a, b) {
            if (a == null && b == null) return 0;
            if (a == null) return -1;
            if (b == null) return 1;
            if (a > b) return 1;
            if (a < b) return -1;
            return 0;
          }

          function applySort() {
            if (sortIndex < 0) return;
            const column = columns[sortIndex];
            const comparator = column.sort || ((rowA, rowB) => {
              const key = column.key;
              const a = typeof key === "function" ? key(rowA) : undefined;
              const b = typeof key === "function" ? key(rowB) : undefined;
              return defaultComparator(a, b);
            });
            rows.sort((a, b) => sortDir * comparator(a, b));
          }

          function persistSortState() {
            if (!sortStateKey) return;
            if (sortIndex < 0) {
              TableSortState.delete(sortStateKey);
            } else {
              TableSortState.set(sortStateKey, {
                index: sortIndex,
                dir: sortDir,
              });
            }
          }

          function syncSortIndicators() {
            [...headerRow.children].forEach((el, headerIdx) => {
              el.classList.remove("asc", "desc");
              if (headerIdx === sortIndex) {
                el.classList.add(sortDir === 1 ? "asc" : "desc");
              }
            });
          }

          columns.forEach((column, idx) => {
            const th = document.createElement("th");
            th.textContent = column.label;
            if (column.tooltip) {
              th.title = column.tooltip;
            }
            if (column.key || column.sort) {
              th.classList.add("sortable");
              th.addEventListener("click", () => {
                if (sortIndex === idx) {
                  sortDir = -sortDir;
                } else {
                  sortIndex = idx;
                  sortDir = 1;
                }
                syncSortIndicators();
                persistSortState();
                applySort();
                renderBody();
              });
            }
            headerRow.appendChild(th);
          });

          thead.appendChild(headerRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");

          function renderBody() {
            tbody.innerHTML = "";
            rows.forEach((row) => {
              const tr = document.createElement("tr");
              columns.forEach((column) => {
                const td = document.createElement("td");
                td.appendChild(column.render(row));
                tr.appendChild(td);
              });
              tbody.appendChild(tr);
            });
          }

          syncSortIndicators();
          applySort();
          persistSortState();
          renderBody();

          table.appendChild(tbody);
          wrapper.appendChild(table);
          return wrapper;
        }

        // =============================================================
        // Tab: Ruoli
        // =============================================================
        function renderRoles() {
          dom.view.innerHTML = "";
          const rows = AppState.data.roles.slice();

          const table = makeTable(
            [
              {
                label: "Titolo",
                key: (role) => (role.title || "").toLowerCase(),
                render: (role) =>
                  inputText(role.title, "Titolo", (value) => {
                    role.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Importanza (≥1)",
                key: (role) => role.importance || 0,
                  render: (role) => {
                      const el = inputInteger(role.importance, (value) => {
                          role.importance = toImportance(value ?? 1); // solo stato
                      });
                      const commit = () => {
                          cascadeFromRole(role);
                          AppState.persist();
                          render();
                      };
                      el.addEventListener("blur", commit);
                      el.addEventListener("change", commit); // per sicurezza
                      el.addEventListener("keydown", (e) => { if (e.key === "Enter") el.blur(); });
                      return el;
                  },
              },
              {
                label: "Azioni",
                render: (role) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.append(
                    button("+ LT", "", () => {
                      role.lt_goals.push(
                        createLongTerm(
                          "Nuovo obiettivo LT",
                          "",
                          3,
                          DateUtils.addDays(90)
                        )
                      );
                      AppState.persist();
                      render();
                    }),
                    button("Elimina", "", () => {
                      if (!confirmDelete("Eliminare ruolo e tutti i figli?"))
                        return;
                      role.lt_goals.forEach((lt) =>
                        lt.st_goals?.forEach((st) => detachShortTermFromSprint(st))
                      );
                      AppState.data.roles = AppState.data.roles.filter(
                        (candidate) => candidate.id !== role.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows,
            { sortKey: "roles-table" }
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Ruolo", "primary", () => {
              AppState.data.roles.push(createRole("Nuovo ruolo", 3));
              AppState.persist();
              render();
            })
          );

          dom.view.append(toolbar, table);
        }

        // =============================================================
        // Tab: Obiettivi Lungo Termine (LT)
        // =============================================================
        function renderLongTermGoals() {
          dom.view.innerHTML = "";
          const rows = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) => rows.push({ role, lt }))
          );

          const table = makeTable(
            [
              {
                label: "Ruolo",
                key: (row) => (row.role.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectRole(row.role.id);
                  select.addEventListener("input", () => {
                    const from = row.role;
                    const to = AppState.data.roles.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!to || from.id === to.id) return;
                    from.lt_goals = from.lt_goals.filter(
                      (goal) => goal.id !== row.lt.id
                    );
                    to.lt_goals.push(row.lt);
                    row.role = to;
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Titolo",
                key: (row) => (row.lt.title || "").toLowerCase(),
                render: (row) =>
                  inputText(row.lt.title, "Titolo", (value) => {
                    row.lt.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Descrizione",
                render: (row) =>
                  textArea(row.lt.description, (value) => {
                    row.lt.description = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Importanza (≥1)",
                key: (row) => row.lt.importance || 0,
                render: (row) =>
                    (() => {
                        const el = inputInteger(row.lt.importance, (value) => {
                            row.lt.importance = toImportance(value ?? 1);
                        });
                        const commit = () => {
                            clampChildToParent(row.lt, row.role);
                            cascadeFromRole(row.role);
                            AppState.persist();
                            render();
                        };
                        el.addEventListener("blur", commit);
                        el.addEventListener("change", commit);
                        el.addEventListener("keydown", (e) => { if (e.key === "Enter") el.blur(); });
                        return el;
                    })(),
              },
              {
                label: "Scadenza",
                key: (row) => row.lt.due || "",
                render: (row) =>
                    (() => {
                        const el = inputDate(row.lt.due, (value) => {
                            row.lt.due = value || DateUtils.today();
                            }, { readOnly: false }); // ← Cambiato a false
                        const commit = () => {
                            clampChildToParent(row.lt, row.role);
                            cascadeFromRole(row.role);
                            AppState.persist();
                            render();
                        };
                        el.addEventListener("blur", commit);
                        el.addEventListener("change", commit);
                        return el;
                    })(),
              }
              ,
              {
                label: "Raggiunto il",
                key: (row) => row.lt.achieved_on || "",
                render: (row) => {
                  const span = document.createElement("span");
                  span.textContent = row.lt.achieved_on || "—";
                  return span;
                },
              },
              {
                label: "Azioni",
                render: (row) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.append(
                    button("+ BT", "", () => {
                      const sprintId = ensureCurrentSprintId().id;
                      const newSt = createShortTerm(
                        "Nuovo obiettivo BT",
                        "",
                        null,
                        null,
                        { sprintId }
                      );
                      row.lt.st_goals.push(newSt);
                      attachShortTermToSprint(newSt, sprintId);
                      AppState.persist();
                      render();
                    }),
                    button("On goal", "", () => {
                      const value = promptForIsoDate(
                        "Data effettiva raggiungimento LT (YYYY-MM-DD)",
                        row.lt.achieved_on || isoToday()
                      );
                      if (value === null) return;
                      row.lt.achieved_on = value ? value : null;
                      AppState.persist();
                      render();
                    }),
                    button("Elimina", "", () => {
                      if (
                        !confirmDelete(
                          "Eliminare obiettivo LT e tutti i figli?"
                        )
                      )
                        return;
                      row.lt.st_goals.forEach((st) =>
                        detachShortTermFromSprint(st)
                      );
                      row.role.lt_goals = row.role.lt_goals.filter(
                        (candidate) => candidate.id !== row.lt.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows,
            { sortKey: "lt-table" }
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Obiettivo LT", "primary", () => {
              if (!AppState.data.roles.length) {
                alert("Prima crea almeno un Ruolo.");
                return;
              }
              AppState.data.roles[0].lt_goals.push(
                createLongTerm(
                  "Nuovo obiettivo LT",
                  "",
                  3,
                  DateUtils.addDays(120)
                )
              );
              AppState.persist();
              render();
            })
          );

          dom.view.append(toolbar, table);
        }

        // =============================================================
        // Tab: Obiettivi Breve Termine (ST)
        // =============================================================
        function renderShortTermGoals() {
          dom.view.innerHTML = "";
          const sprintContext = getSprintUiContext();
          const { selectedSprint } = sprintContext;
          const sprintDrawer = createSprintDrawer(sprintContext, {
            startOpen: true,
            label: "Gestione sprint",
            syncShortTerm: true,
            stateKey: "st",
          });

          const rows = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) =>
              lt.st_goals.forEach((st) => {
                if (selectedSprint && st.sprint_id !== selectedSprint.id) {
                  return;
                }
                rows.push({ role, lt, st });
              })
            )
          );

          const table = makeTable(
            [
              {
                label: "Ruolo",
                key: (row) => (row.role.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectRole(row.role.id);
                  select.addEventListener("input", () => {
                    const newRole = AppState.data.roles.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!newRole || newRole.id === row.role.id) return;
                    row.lt.st_goals = row.lt.st_goals.filter(
                      (candidate) => candidate.id !== row.st.id
                    );
                    if (!newRole.lt_goals.length) {
                      newRole.lt_goals.push(
                        createLongTerm(
                          "Auto creato",
                          "",
                          row.lt.importance,
                          row.lt.due
                        )
                      );
                    }
                    const targetLT = newRole.lt_goals[0];
                    targetLT.st_goals.push(row.st);
                    row.role = newRole;
                    row.lt = targetLT;
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "LT",
                key: (row) => (row.lt.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectLongTerm(row.role.id, row.lt.id);
                  select.addEventListener("input", () => {
                    const target = row.role.lt_goals.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!target) return;
                    row.lt.st_goals = row.lt.st_goals.filter(
                      (candidate) => candidate.id !== row.st.id
                    );
                    target.st_goals.push(row.st);
                    row.lt = target;
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Titolo",
                key: (row) => (row.st.title || "").toLowerCase(),
                render: (row) =>
                  inputText(row.st.title, "Titolo", (value) => {
                    row.st.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Descrizione",
                render: (row) =>
                  textArea(row.st.description, (value) => {
                    row.st.description = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Importanza (ereditata se vuota)",
                key: (row) =>
                  effectiveImportance(row.st, row.lt.importance ?? 1) || 0,
                render: (row) => {
                  const el = inputInteger(row.st.importance, (value) => {
                    row.st.importance = value;
                    enforceBounds();
                  });

                  const enforceBounds = () => {
                    const parentImportance = effectiveImportance(
                      row.lt,
                      row.role.importance ?? 1
                    );
                    if (
                      row.st.importance != null &&
                      parentImportance != null &&
                      row.st.importance > parentImportance
                    ) {
                      row.st.importance = parentImportance;
                      el.value = String(parentImportance);
                    }
                  };

                  const commit = () => {
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  };

                  el.addEventListener("blur", commit);
                  el.addEventListener("change", commit);
                  el.addEventListener("keydown", (event) => {
                    if (event.key === "Enter") el.blur();
                  });

                  enforceBounds();

                  return el;
                },
              },
              {
                label: "Scadenza (ereditata se vuota)",
                key: (row) => effectiveDueDate(row.st, row.lt.due) || "",
                render: (row) => {
                  const el = inputDate(
                    row.st.due,
                    (value) => {
                      row.st.due = value;
                    },
                    { readOnly: false }
                  );
                  el.addEventListener("blur", () => {
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  });
                  return el;
                },
              },
              {
                label: "Sprint",
                key: (row) => row.st.sprint_id || "",
                render: (row) => {
                  const select = document.createElement("select");
                  AppState.data.sprints.forEach((sprint) => {
                    const option = document.createElement("option");
                    option.value = sprint.id;
                    option.textContent = sprint.name || formatSprintRange(sprint);
                    select.appendChild(option);
                  });
                  if (!row.st.sprint_id && AppState.data.sprints.length) {
                    row.st.sprint_id = AppState.data.sprints[0].id;
                  }
                  select.value = row.st.sprint_id || "";
                  select.addEventListener("change", () => {
                    attachShortTermToSprint(row.st, select.value);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Raggiunto il",
                key: (row) => row.st.achieved_on || "",
                render: (row) => {
                  const span = document.createElement("span");
                  span.textContent = row.st.achieved_on || "—";
                  return span;
                },
              },
              {
                label: "Azioni",
                render: (row) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.append(
                    button("+ Attività", "", () => {
                      const task = createTask("Nuova attività", "", null, null);
                      row.st.tasks.push(task);
                      AppState.persist();
                      render();
                    }),
                    button("On goal", "", () => {
                      const value = promptForIsoDate(
                        "Data effettiva raggiungimento BT (YYYY-MM-DD)",
                        row.st.achieved_on || isoToday()
                      );
                      if (value === null) return;
                      row.st.achieved_on = value ? value : null;
                      AppState.persist();
                      render();
                    }),
                    button("Elimina", "", () => {
                      if (!confirmDelete("Eliminare obiettivo BT?")) return;
                      detachShortTermFromSprint(row.st);
                      row.lt.st_goals = row.lt.st_goals.filter(
                        (candidate) => candidate.id !== row.st.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows,
            { sortKey: "st-table" }
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Obiettivo BT", "primary", () => {
              if (!AppState.data.roles.length) {
                alert("Crea prima Ruolo > LT");
                return;
              }
              const role = AppState.data.roles[0];
              if (!role.lt_goals.length) {
                role.lt_goals.push(
                  createLongTerm(
                    "Nuovo obiettivo LT",
                    "",
                    3,
                    DateUtils.addDays(120)
                  )
                );
              }
              const sprintId =
                selectedSprintId || ensureCurrentSprintId().id || null;
              const newSt = createShortTerm(
                "Nuovo obiettivo BT",
                "",
                null,
                null,
                { sprintId }
              );
              role.lt_goals[0].st_goals.push(newSt);
              attachShortTermToSprint(newSt, sprintId);
              AppState.persist();
              render();
            })
          );

          dom.view.append(sprintDrawer, toolbar, table);
        }

        // =============================================================
        // Tab: Attività
        // =============================================================
        function renderTasks() {
          dom.view.innerHTML = "";
          const sprintContext = getSprintUiContext();
          const sprintDrawer = createSprintDrawer(sprintContext, {
            label: "Gestione sprint",
            startOpen: false,
            stateKey: "tasks",
          });
          const rows = getFilteredTaskRefs();

          const filtersDrawer = createFiltersDrawer({
            onExport: () => exportTasksToCsv(getFilteredTaskRefs()),
            onImport: () => requestTaskCsvImport(),
            stateKey: "tasks",
          });

          const table = makeTable(
            [
              {
                label: "Ruolo",
                key: (row) => (row.role.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectRole(row.role.id);
                  select.addEventListener("input", () => {
                    const newRole = AppState.data.roles.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!newRole || newRole.id === row.role.id) return;
                    row.st.tasks = row.st.tasks.filter(
                      (candidate) => candidate.id !== row.task.id
                    );
                    if (!newRole.lt_goals.length) {
                      newRole.lt_goals.push(
                        createLongTerm(
                          "Auto creato",
                          "",
                          row.lt.importance,
                          row.lt.due
                        )
                      );
                    }
                    const targetLT = newRole.lt_goals[0];
                    if (!targetLT.st_goals.length) {
                      const autoSt = createShortTerm(
                        "Auto creato",
                        "",
                        row.st.importance,
                        row.st.due,
                        { sprintId: row.st.sprint_id }
                      );
                      targetLT.st_goals.push(autoSt);
                      attachShortTermToSprint(autoSt, row.st.sprint_id);
                    }
                    const targetST = targetLT.st_goals[0];
                    targetST.tasks.push(row.task);
                    row.role = newRole;
                    row.lt = targetLT;
                    row.st = targetST;
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "LT",
                key: (row) => (row.lt.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectLongTerm(row.role.id, row.lt.id);
                  select.addEventListener("input", () => {
                    const target = row.role.lt_goals.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!target) return;
                    row.st.tasks = row.st.tasks.filter(
                      (candidate) => candidate.id !== row.task.id
                    );
                    if (!target.st_goals.length) {
                      const autoSt = createShortTerm(
                        "Auto creato",
                        "",
                        row.st.importance,
                        row.st.due,
                        { sprintId: row.st.sprint_id }
                      );
                      target.st_goals.push(autoSt);
                      attachShortTermToSprint(autoSt, row.st.sprint_id);
                    }
                    const targetST = target.st_goals[0];
                    targetST.tasks.push(row.task);
                    row.lt = target;
                    row.st = targetST;
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "BT",
                key: (row) => (row.st.title || "").toLowerCase(),
                render: (row) => {
                  const select = document.createElement("select");
                  row.lt.st_goals.forEach((st) => {
                    const option = document.createElement("option");
                    option.value = st.id;
                    option.textContent = st.title;
                    select.appendChild(option);
                  });
                  select.value = row.st.id;
                  select.addEventListener("input", () => {
                    const target = row.lt.st_goals.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!target) return;
                    row.st.tasks = row.st.tasks.filter(
                      (candidate) => candidate.id !== row.task.id
                    );
                    target.tasks.push(row.task);
                    row.st = target;
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Titolo",
                key: (row) => (row.task.title || "").toLowerCase(),
                render: (row) =>
                  inputText(row.task.title, "Titolo", (value) => {
                    row.task.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Descrizione",
                render: (row) =>
                  textArea(row.task.description, (value) => {
                    row.task.description = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Stato",
                key: (row) =>
                  getTaskStateConfig(row.task.state).label.toLowerCase(),
                render: (row) => createTaskStateSelect(row.task),
              },
              {
                label: "I",
                tooltip: "Importanza (ereditata se vuota)",
                key: (row) =>
                  effectiveImportance(
                    row.task,
                    effectiveImportance(row.st, row.lt.importance)
                  ) || 0,
                render: (row) => {
                  const el = inputInteger(row.task.importance, (value) => {
                    row.task.importance = value;
                  });
                  const commit = () => {
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  };
                  el.addEventListener("blur", commit);
                  el.addEventListener("change", commit);
                  el.addEventListener("keydown", (event) => {
                    if (event.key === "Enter") el.blur();
                  });
                  return el;
                },
              },
              {
                label: "Stima (h)",
                tooltip: "Stima dell'attività in ore (decimali ammessi)",
                key: (row) => row.task.estimate_hours ?? -1,
                render: (row) => {
                  const el = inputHours(row.task.estimate_hours, (value) => {
                    row.task.estimate_hours = value;
                  });
                  const commit = () => {
                    AppState.persist();
                    render();
                  };
                  el.addEventListener("blur", commit);
                  el.addEventListener("keydown", (event) => {
                    if (event.key === "Enter") el.blur();
                  });
                  return el;
                },
              },
              {
                label: "Priority",
                tooltip: "Calcolo automatico su tempo/importanza",
                key: (row) => getTaskMetrics(row)?.priority ?? 0,
                render: (row) => createPriorityChip(getTaskMetrics(row)),
              },
              {
                label: "Quadrante",
                tooltip: "Quadrante Q1-Q4 calcolato",
                key: (row) => getTaskMetrics(row)?.quadrant || "",
                render: (row) => {
                  const quadrant = getTaskMetrics(row)?.quadrant || "-";
                  return createQuadrantBadge(quadrant);
                },
              },
              {
                label: "Scad.",
                tooltip: "Scadenza (ereditata se vuota)",
                key: (row) => resolveTaskDueDate(row.lt, row.st, row.task) || "",
                render: (row) => {
                  const el = inputDate(
                    row.task.due,
                    (value) => {
                      row.task.due = value;
                    },
                    { readOnly: false }
                  ); // ← Cambiato a false
                  el.addEventListener("blur", () => {
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return el;
                },
              },
              {
                label: "Chiuso il",
                key: (row) => row.task.closed_on || "",
                render: (row) => {
                  const el = inputDate(
                    row.task.closed_on,
                    (value) => {
                      row.task.closed_on = value || null;
                    },
                    { readOnly: false }
                  );
                  const persist = () => AppState.persist();
                  el.addEventListener("change", persist);
                  el.addEventListener("blur", persist);
                  return el;
                },
              },
              {
                label: "Azioni",
                render: (row) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.appendChild(
                    button("Elimina", "", () => {
                      if (!confirmDelete("Eliminare attività?")) return;
                      row.st.tasks = row.st.tasks.filter(
                        (candidate) => candidate.id !== row.task.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows,
            { sortKey: "tasks-table" }
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Attività", "primary", () => {
              const sprintId =
                selectedSprintId || AppState.data.currentSprintId || null;
              if (!sprintId) {
                alert("Crea prima il primo ST per questo sprint");
                return;
              }

              const shortTerms = [];
              AppState.data.roles.forEach((role) =>
                role.lt_goals.forEach((lt) =>
                  lt.st_goals.forEach((st) => {
                    if (st.sprint_id === sprintId) {
                      shortTerms.push({ role, lt, st });
                    }
                  })
                )
              );

              if (!shortTerms.length) {
                alert("Crea prima il primo ST per questo sprint");
                return;
              }

              const { roleId, ltId, stId } = TaskFilters;
              let targetEntry = null;
              if (stId) {
                targetEntry = shortTerms.find(({ st }) => st.id === stId) || null;
              }
              if (!targetEntry && ltId) {
                targetEntry = shortTerms.find(({ lt }) => lt.id === ltId) || null;
              }
              if (!targetEntry && roleId) {
                targetEntry =
                  shortTerms.find(({ role }) => role.id === roleId) || null;
              }
              if (!targetEntry) {
                targetEntry = shortTerms[0];
              }

              targetEntry.st.tasks.push(
                createTask("Nuova attività", "", null, null)
              );
              AppState.persist();
              render();
            })
          );

          dom.view.append(sprintDrawer, filtersDrawer, toolbar, table);
        }

        // =============================================================
        // Tab: Dashboard
        // =============================================================
        function renderDashboard() {
          dom.view.innerHTML = "";
          const sprintContext = getSprintUiContext();
          const sprintDrawer = createSprintDrawer(sprintContext, {
            label: "Gestione sprint",
            startOpen: false,
            stateKey: "dash",
          });
          const filtersDrawer = createFiltersDrawer({
            onExport: () => exportTasksToCsv(getFilteredTaskRefs()),
            onImport: () => requestTaskCsvImport(),
            stateKey: "dash",
          });
          const kanban = document.createElement("div");
          kanban.className = "kanban";

          const columns = new Map();
          TASK_STATES.forEach((state) => {
            const column = createKanbanColumn(state);
            columns.set(state.id, column);
            kanban.appendChild(column.element);
          });

          const refsByState = new Map();
          getFilteredTaskRefs().forEach((ref) => {
            const stateId = getTaskStateId(ref.task.state);
            if (!refsByState.has(stateId)) {
              refsByState.set(stateId, []);
            }
            refsByState.get(stateId).push(ref);
          });

          columns.forEach((column, stateId) => {
            column.body.innerHTML = "";
            const refs = refsByState.get(stateId) || [];
            refs.sort((a, b) => {
              const impA = effectiveImportance(
                a.task,
                effectiveImportance(a.st, a.lt.importance)
              ) ?? 0;
              const impB = effectiveImportance(
                b.task,
                effectiveImportance(b.st, b.lt.importance)
              ) ?? 0;
              return impB - impA;
            });

            refs.forEach((ref) => {
              column.body.appendChild(createKanbanCard(ref));
            });

            column.count = refs.length;
            column.countEl.textContent = String(column.count);

            if (!column.count) {
              column.body.appendChild(column.placeholder);
            }
          });

          dom.view.append(sprintDrawer, filtersDrawer, kanban);
        }

        // =============================================================
        // Tab: Statistiche
        // =============================================================
        function renderStatistics() {
          dom.view.innerHTML = "";
          const sprintContext = getSprintUiContext();
          const sprintDrawer = createSprintDrawer(sprintContext, {
            label: "Gestione sprint",
            startOpen: false,
            stateKey: "stats",
          });
          const filtersDrawer = createFiltersDrawer({
            onExport: () => exportTasksToCsv(getFilteredTaskRefs()),
            onImport: () => requestTaskCsvImport(),
            stateKey: "stats",
          });

          const panels = document.createElement("div");
          panels.className = "panel-grid";
          panels.appendChild(createTaskQuadrantsPanel());
          panels.appendChild(createBurndownPanel());
          panels.appendChild(createLongTermQuadrantsPanel());

          dom.view.append(sprintDrawer, filtersDrawer, panels);
        }

        const format3Sig = (value) => {
          const num = Number(value);
          return Number.isFinite(num) ? Number(num).toPrecision(3) : "-";
        };

        function createBurndownPanel() {
          const sprintId = selectedSprintId || AppState.data.currentSprintId || null;
          const sprint = (AppState.data.sprints || []).find(
            (candidate) => candidate.id === sprintId
          );

          const panel = document.createElement("article");
          panel.className = "panel";

          const header = document.createElement("div");
          header.className = "panel-header";
          const heading = document.createElement("h3");
          heading.textContent = "Burndown sprint";
          const actions = document.createElement("div");
          actions.className = "panel-actions";
          const fullscreenBtn = button("Fullscreen", "", () => {
            panel.classList.toggle("fullscreen");
            fullscreenBtn.textContent = panel.classList.contains("fullscreen")
              ? "Chiudi"
              : "Fullscreen";
          });
          actions.append(fullscreenBtn);
          header.append(heading, actions);

          const body = document.createElement("div");
          body.className = "panel-body";

          if (!sprint) {
            body.textContent = "Seleziona uno sprint per visualizzare il burndown.";
            panel.append(header, body);
            return panel;
          }

          const timeline = buildSprintTimeline(sprint.start, sprint.end);
          if (!timeline.length) {
            body.textContent =
              "Imposta date di inizio/fine sprint per visualizzare il burndown.";
            panel.append(header, body);
            return panel;
          }

          const sprintTasks = getFilteredTaskRefs().filter(
            ({ st }) => st.sprint_id === sprintId
          );
          if (!sprintTasks.length) {
            body.textContent = "Nessuna attività nello sprint selezionato.";
            panel.append(header, body);
            return panel;
          }

          const totalEffort = sprintTasks.reduce((sum, { task }) => {
            return sum + getTaskEffortHours(task);
          }, 0);

          if (totalEffort <= 0) {
            body.textContent =
              "Nessuna stima di effort disponibile per il burndown dello sprint.";
            panel.append(header, body);
            return panel;
          }

          const actualSeries = buildBurndownSeries(
            timeline,
            sprintTasks,
            totalEffort
          );
          const idealSeries = buildIdealBurndownSeries(timeline, totalEffort);
          const chart = createBurndownChart(
            timeline,
            actualSeries,
            idealSeries,
            totalEffort
          );

          const legend = createBurndownLegend();
          const summary = createBurndownSummary(actualSeries, totalEffort, sprint);

          body.append(chart, legend, summary);
          panel.append(header, body);
          return panel;
        }

        function buildSprintTimeline(start, end) {
          if (!start || !end) return [];
          const startDate = new Date(start);
          const endDate = new Date(end);
          if (Number.isNaN(startDate) || Number.isNaN(endDate)) return [];
          if (startDate > endDate) return [];
          const dates = [];
          const cursor = new Date(startDate);
          while (cursor <= endDate) {
            dates.push(cursor.toISOString().slice(0, 10));
            cursor.setDate(cursor.getDate() + 1);
          }
          return dates;
        }

        function clampIsoDate(value, min, max) {
          const fallback = max || min;
          if (!value && !fallback) return null;
          const minDate = min ? new Date(min) : null;
          const maxDate = max ? new Date(max) : null;
          let parsed = value ? new Date(value) : fallback ? new Date(fallback) : null;
          if (!parsed || Number.isNaN(parsed)) {
            parsed = fallback ? new Date(fallback) : null;
          }
          if (!parsed) return null;
          if (minDate && parsed < minDate) parsed = minDate;
          if (maxDate && parsed > maxDate) parsed = maxDate;
          return parsed.toISOString().slice(0, 10);
        }

        function buildBurndownSeries(timeline, refs, totalEffort) {
          const burnsByDate = new Map();
          const start = timeline[0];
          const end = timeline[timeline.length - 1];
          refs.forEach(({ task }) => {
            const stateId = getTaskStateId(task.state);
            if (!CLOSING_TASK_STATES.has(stateId)) return;
            const effort = getTaskEffortHours(task);
            const closedOn = clampIsoDate(task.closed_on, start, end) || end;
            const current = burnsByDate.get(closedOn) || 0;
            burnsByDate.set(closedOn, current + effort);
          });

          let remaining = totalEffort;
          return timeline.map((date) => {
            const burn = burnsByDate.get(date) || 0;
            remaining = Math.max(0, remaining - burn);
            return { date, remaining };
          });
        }

        function buildIdealBurndownSeries(timeline, totalEffort) {
          if (!timeline.length) return [];
          if (timeline.length === 1) return [{ date: timeline[0], remaining: 0 }];
          const step = totalEffort / (timeline.length - 1);
          return timeline.map((date, index) => ({
            date,
            remaining: Math.max(0, totalEffort - step * index),
          }));
        }

        function createBurndownChart(timeline, actual, ideal, totalEffort) {
          const chart = document.createElement("div");
          chart.className = "burndown-chart";

          const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          const viewWidth = 200;
          const viewHeight = 100;
          const padding = 10;
          const paddingPercent = (padding / viewWidth) * 100;
          chart.style.setProperty("--burndown-padding-pct", `${paddingPercent}%`);
          const innerWidth = viewWidth - padding * 2;
          const innerHeight = viewHeight - padding * 2;
          svg.setAttribute("viewBox", `0 0 ${viewWidth} ${viewHeight}`);
          svg.setAttribute("role", "img");
          svg.setAttribute("aria-label", "Burndown chart dello sprint");

          const toPoint = (entry, index) => {
            const x =
              padding +
              (timeline.length > 1
                ? (innerWidth * index) / (timeline.length - 1)
                : innerWidth / 2);
            const ratio = totalEffort > 0 ? entry.remaining / totalEffort : 0;
            const clampedRatio = Math.min(1, Math.max(0, ratio));
            const y = padding + (1 - clampedRatio) * innerHeight;
            return `${x},${y}`;
          };

          const plotArea = document.createElement("div");
          plotArea.className = "burndown-plot-area";

          for (let i = 0; i <= 4; i += 1) {
            const y = padding + (innerHeight / 4) * i;
            const grid = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );
            grid.setAttribute("x1", padding);
            grid.setAttribute("x2", viewWidth - padding);
            grid.setAttribute("y1", y);
            grid.setAttribute("y2", y);
            grid.setAttribute("class", "burndown-grid-line");
            svg.appendChild(grid);
          }

          const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
          yAxis.setAttribute("x1", padding);
          yAxis.setAttribute("x2", padding);
          yAxis.setAttribute("y1", padding);
          yAxis.setAttribute("y2", viewHeight - padding);
          yAxis.setAttribute("class", "burndown-axis");
          svg.appendChild(yAxis);

          const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
          xAxis.setAttribute("x1", padding);
          xAxis.setAttribute("x2", viewWidth - padding);
          xAxis.setAttribute("y1", viewHeight - padding);
          xAxis.setAttribute("y2", viewHeight - padding);
          xAxis.setAttribute("class", "burndown-axis");
          svg.appendChild(xAxis);

          const idealPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "polyline"
          );
          idealPath.setAttribute(
            "points",
            ideal.map((entry, idx) => toPoint(entry, idx)).join(" ")
          );
          idealPath.setAttribute("class", "burndown-path ideal");
          svg.appendChild(idealPath);

          const actualPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "polyline"
          );
          actualPath.setAttribute(
            "points",
            actual.map((entry, idx) => toPoint(entry, idx)).join(" ")
          );
          actualPath.setAttribute("class", "burndown-path actual");
          svg.appendChild(actualPath);

          actual.forEach((entry, idx) => {
            const [x, y] = toPoint(entry, idx).split(",").map(Number);
            const circle = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle"
            );
            circle.setAttribute("cx", x);
            circle.setAttribute("cy", y);
            circle.setAttribute("r", 1.8);
            circle.setAttribute("class", "burndown-point");
            svg.appendChild(circle);
          });

          plotArea.appendChild(svg);

          const yLabels = document.createElementNS("http://www.w3.org/2000/svg", "g");
          yLabels.setAttribute("class", "burndown-axis-text y-labels");
          const seenEfforts = new Set();
          const effortRows = [];
          actual.forEach((entry, idx) => {
            const key = `${entry.remaining}`;
            if (seenEfforts.has(key)) return;
            seenEfforts.add(key);
            const [, y] = toPoint(entry, idx).split(",").map(Number);
            effortRows.push({ value: entry.remaining, y });
          });
          effortRows
            .sort((a, b) => a.y - b.y)
            .forEach((row) => {
              const label = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              label.setAttribute("class", "burndown-axis-text y-label");
              label.setAttribute("x", padding - 1.2);
              label.setAttribute("y", row.y);
              label.textContent = `${formatHours(row.value)} h`;
              yLabels.appendChild(label);
            });
          svg.appendChild(yLabels);

          const xLabels = document.createElementNS("http://www.w3.org/2000/svg", "g");
          xLabels.setAttribute("class", "burndown-axis-text x-labels");
          const xLabelOffset = 4.2;
          timeline.forEach((date, idx) => {
            const [x] = toPoint(actual[idx], idx).split(",").map(Number);
            const label = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            label.setAttribute("class", "burndown-axis-text x-label");
            label.setAttribute("x", x);
            label.setAttribute("y", viewHeight - padding + xLabelOffset);
            label.textContent = formatDayOfMonth(date);
            label.setAttribute("aria-label", formatShortDate(date));
            xLabels.appendChild(label);
          });
          svg.appendChild(xLabels);

          chart.appendChild(plotArea);

          return chart;
        }

        function createBurndownLegend() {
          const container = document.createElement("div");
          container.className = "burndown-legend";

          const actual = document.createElement("span");
          actual.className = "legend-item";
          const actualSwatch = document.createElement("span");
          actualSwatch.className = "legend-swatch";
          actualSwatch.style.background = "#22c55e";
          actual.append(actualSwatch, document.createTextNode("Andamento reale"));

          const ideal = document.createElement("span");
          ideal.className = "legend-item";
          const idealSwatch = document.createElement("span");
          idealSwatch.className = "legend-swatch";
          idealSwatch.style.background = "#38bdf8";
          ideal.append(idealSwatch, document.createTextNode("Linea ideale"));

          container.append(actual, ideal);
          return container;
        }

        function createBurndownSummary(series, totalEffort, sprint) {
          const container = document.createElement("div");
          container.className = "burndown-summary";
          const remaining = series[series.length - 1]?.remaining ?? totalEffort;
          const burned = Math.max(0, totalEffort - remaining);

          const totalPill = document.createElement("span");
          totalPill.className = "pill";
          totalPill.textContent = `Effort totale stimato: ${formatHours(
            totalEffort
          )} h`;

          const burnedPill = document.createElement("span");
          burnedPill.className = "pill";
          burnedPill.textContent = `Consumato: ${formatHours(burned)} h`;

          const remainingPill = document.createElement("span");
          remainingPill.className = "pill";
          remainingPill.textContent = `Residuo: ${formatHours(remaining)} h`;

          const windowPill = document.createElement("span");
          windowPill.className = "pill";
          windowPill.textContent = `Finestra sprint: ${formatShortDate(
            sprint.start
          )} → ${formatShortDate(sprint.end)}`;

          container.append(totalPill, burnedPill, remainingPill, windowPill);
          return container;
        }

        function getTaskEffortHours(task) {
          const rawEffort = Number(task?.estimate_hours);
          if (!Number.isFinite(rawEffort) || rawEffort <= 0) return 1;
          return rawEffort;
        }

        function formatDayOfMonth(value) {
          try {
            const parsed = new Date(value);
            const day = parsed.getDate();
            if (Number.isNaN(day)) return value;
            return String(day).padStart(2, "0");
          } catch (err) {
            return value;
          }
        }

        function formatShortDate(value) {
          if (!value) return "-";
          try {
            return new Date(value).toLocaleDateString("it-IT", {
              day: "2-digit",
              month: "2-digit",
            });
          } catch (err) {
            return value;
          }
        }

        function createTaskQuadrantsPanel() {
          const sprintId = selectedSprintId || AppState.data.currentSprintId || null;
          const sprintTasks = getFilteredTaskRefs().filter(
            ({ st }) => st.sprint_id === sprintId
          );

          const thresholds = getQuadrantThresholdPercents();
          const points = sprintTasks
            .map((ref) => {
              const metrics = getTaskMetrics(ref);
              if (!metrics) return null;
              const stateConfig = getTaskStateConfig(ref.task.state);
              const leftPercent = (1 - metrics.normalizedTime) * 100;
              const topPercent = (1 - metrics.normalizedImportance) * 100;
              const title = `${ref.task.id} • ${
                ref.task.title || "(Senza titolo)"
              }`;
              const timeValue = format3Sig(metrics.timePriority).replace(
                ".",
                ","
              );
              const impValue = format3Sig(metrics.importancePriority).replace(
                ".",
                ","
              );
              const timeThreshold = format3Sig(
                metrics.timeThreshold ?? TaskMetricsCache.stats?.timeThreshold
              ).replace(".", ",");
              const impThreshold = format3Sig(
                metrics.impThreshold ?? TaskMetricsCache.stats?.impThreshold
              ).replace(".", ",");

              return {
                color: stateConfig?.color || "#38bdf8",
                leftPercent,
                topPercent,
                tooltipData: {
                  title,
                  timeValue,
                  impValue,
                  timeThreshold,
                  impThreshold,
                },
              };
            })
            .filter(Boolean);

          return createQuadrantPanel({
            title: "Quadranti attività dello sprint",
            thresholds,
            points,
            emptyMessage: "Nessuna attività nello sprint selezionato.",
          });
        }

        function buildLongTermQuadrantMetrics() {
          const refs = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) => refs.push({ role, lt }))
          );

          if (!refs.length) {
            return { thresholds: null, points: [] };
          }

          const today = new Date();
          const dayValues = [];
          const importanceValues = [];

          refs.forEach(({ lt }) => {
            dayValues.push(computeDaysRemaining(lt.due, today));
            importanceValues.push(toImportance(lt.importance, 1));
          });

          const context = buildPriorityContext(
            dayValues,
            importanceValues,
            PRIORITY_CONFIG
          );

          if (!context) {
            return { thresholds: null, points: [] };
          }

          const stats = {
            priorityMin: PRIORITY_CONFIG.MIN_PRIORITY,
            priorityMax: PRIORITY_CONFIG.MAX_PRIORITY,
            timeThreshold: context.timeThreshold,
            impThreshold: context.impThreshold,
          };

          const priorityRange = context.priorityRange;
          const points = refs.map((ref, index) => {
            const timePriority =
              context.timePriorities[index] ?? PRIORITY_CONFIG.MIN_PRIORITY;
            const importancePriority =
              context.impPriorities[index] ?? PRIORITY_CONFIG.MIN_PRIORITY;
            const normalizedTime = Math.min(
              1,
              Math.max(
                0,
                (timePriority - PRIORITY_CONFIG.MIN_PRIORITY) / priorityRange
              )
            );
            const normalizedImportance = Math.min(
              1,
              Math.max(
                0,
                (importancePriority - PRIORITY_CONFIG.MIN_PRIORITY) / priorityRange
              )
            );
            const title = `${ref.lt.id} • ${ref.lt.title || "(Senza titolo)"}`;
            const timeValue = format3Sig(timePriority).replace(".", ",");
            const impValue = format3Sig(importancePriority).replace(".", ",");
            const timeThreshold = format3Sig(context.timeThreshold).replace(
              ".",
              ","
            );
            const impThreshold = format3Sig(context.impThreshold).replace(
              ".",
              ","
            );

            return {
              color: "#6366f1",
              leftPercent: (1 - normalizedTime) * 100,
              topPercent: (1 - normalizedImportance) * 100,
              tooltipData: {
                title,
                timeValue,
                impValue,
                timeThreshold,
                impThreshold,
              },
            };
          });

          return { thresholds: stats, points };
        }

        function createLongTermQuadrantsPanel() {
          const { thresholds, points } = buildLongTermQuadrantMetrics();
          return createQuadrantPanel({
            title: "Quadranti obiettivi a lungo termine",
            thresholds: thresholds
              ? getQuadrantThresholdPercents(thresholds)
              : { time: 50, importance: 50 },
            points,
            emptyMessage: "Nessun obiettivo a lungo termine disponibile.",
          });
        }

        function createQuadrantPanel({ title, thresholds, points, emptyMessage }) {
          const panel = document.createElement("article");
          panel.className = "panel";

          const header = document.createElement("div");
          header.className = "panel-header";
          const heading = document.createElement("h3");
          heading.textContent = title;
          const actions = document.createElement("div");
          actions.className = "panel-actions";
          const fullscreenBtn = button("Fullscreen", "", () => {
            panel.classList.toggle("fullscreen");
            fullscreenBtn.textContent = panel.classList.contains("fullscreen")
              ? "Chiudi"
              : "Fullscreen";
          });
          actions.append(fullscreenBtn);
          header.append(heading, actions);

          const chart = document.createElement("div");
          chart.className = "quadrant-chart";
          const axisThresholds = thresholds || { time: 50, importance: 50 };
          createQuadrantBackgrounds(axisThresholds).forEach((bg) =>
            chart.appendChild(bg)
          );
          const verticalAxis = createAxisLine("vertical");
          const horizontalAxis = createAxisLine("horizontal");
          chart.append(verticalAxis, horizontalAxis);

          verticalAxis.style.left = `${axisThresholds.time}%`;
          horizontalAxis.style.top = `${axisThresholds.importance}%`;

          const ihLabel = createAxisLabel("IH", "importance-top");
          const ilLabel = createAxisLabel("IL", "importance-bottom");
          const thLabel = createAxisLabel("TH", "time-left");
          const tlLabel = createAxisLabel("TL", "time-right");

          const importanceValue = document.createElement("div");
          importanceValue.className = "axis-value importance";
          importanceValue.style.top = `${axisThresholds.importance}%`;
          const importanceValueText =
            axisThresholds.importanceValue != null
              ? format3Sig(axisThresholds.importanceValue).replace(".", ",")
              : "-";
          importanceValue.textContent = importanceValueText;

          const timeValue = document.createElement("div");
          timeValue.className = "axis-value time";
          timeValue.style.left = `${axisThresholds.time}%`;
          const timeValueText =
            axisThresholds.timeValue != null
              ? format3Sig(axisThresholds.timeValue).replace(".", ",")
              : "-";
          timeValue.textContent = timeValueText;

          const tooltip = document.createElement("div");
          tooltip.className = "chart-tooltip";
          chart.append(
            ihLabel,
            ilLabel,
            thLabel,
            tlLabel,
            importanceValue,
            timeValue,
            tooltip
          );

          if (!points.length) {
            const empty = document.createElement("p");
            empty.textContent = emptyMessage;
            empty.style.color = "var(--muted)";
            chart.appendChild(empty);
          } else {
            const clampPercent = (value) =>
              Math.min(94, Math.max(6, Math.round(value)));
            const placeTooltip = (leftPercent, topPercent) => {
              const chartWidth = chart.clientWidth;
              const chartHeight = chart.clientHeight;
              const padding = 12;
              const leftPx = (leftPercent / 100) * chartWidth;
              const topPx = (topPercent / 100) * chartHeight;
              const { offsetWidth, offsetHeight } = tooltip;
              const halfW = offsetWidth / 2;
              const topOffset = 14;
              const clampedLeft = Math.min(
                chartWidth - padding - halfW,
                Math.max(padding + halfW, leftPx)
              );
              const clampedTop = Math.min(
                chartHeight - padding - offsetHeight,
                Math.max(padding + offsetHeight, topPx - topOffset)
              );
              tooltip.style.left = `${clampedLeft}px`;
              tooltip.style.top = `${clampedTop}px`;
            };
            points.forEach((point) => {
              const dot = document.createElement("span");
              dot.className = "quadrant-point";
              dot.style.background = point.color;
              const left = clampPercent(point.leftPercent);
              const top = clampPercent(point.topPercent);
              dot.style.left = `${left}%`;
              dot.style.top = `${top}%`;

              dot.addEventListener("mouseenter", () => {
                const title = point.tooltipData?.title || point.tooltip || "";
                const timeValue = point.tooltipData?.timeValue || "-";
                const impValue = point.tooltipData?.impValue || "-";

                tooltip.innerHTML = `
                  <div class="tooltip-title">${title}</div>
                  <div class="tooltip-body">T: ${timeValue} | I: ${impValue}</div>
                `;
                placeTooltip(left, top);
                tooltip.style.opacity = "1";
              });
              dot.addEventListener("mouseleave", () => {
                tooltip.style.opacity = "0";
              });

              chart.appendChild(dot);
            });
          }

          panel.append(header, chart);
          return panel;
        }

        function createAxisLine(variant) {
          const line = document.createElement("div");
          line.className = `axis-line ${variant}`;
          return line;
        }

        function createAxisLabel(text, variant) {
          const label = document.createElement("span");
          label.className = "axis-label";
          if (variant) label.classList.add(variant);
          label.textContent = text;
          return label;
        }

        function createQuadrantBackgrounds(thresholds) {
          const clampPercent = (value) => Math.min(100, Math.max(0, value));
          const timeSplit = clampPercent(thresholds.time);
          const impSplit = clampPercent(thresholds.importance);
          const configs = [
            {
              quadrant: "q1",
              style: {
                top: "0%",
                left: "0%",
                right: `${100 - timeSplit}%`,
                bottom: `${100 - impSplit}%`,
              },
            },
            {
              quadrant: "q2",
              style: {
                top: "0%",
                left: `${timeSplit}%`,
                right: "0%",
                bottom: `${100 - impSplit}%`,
              },
            },
            {
              quadrant: "q3",
              style: {
                top: `${impSplit}%`,
                left: "0%",
                right: `${100 - timeSplit}%`,
                bottom: "0%",
              },
            },
            {
              quadrant: "q4",
              style: {
                top: `${impSplit}%`,
                left: `${timeSplit}%`,
                right: "0%",
                bottom: "0%",
              },
            },
          ];

          return configs.map(({ quadrant, style }) => {
            const bg = document.createElement("div");
            bg.className = `quadrant-bg ${quadrant}`;
            Object.assign(bg.style, style);
            return bg;
          });
        }

        function getQuadrantThresholdPercents(statsOverride = null) {
          if (!statsOverride) {
            computeTaskMetricsCache();
          }
          const stats = statsOverride || TaskMetricsCache.stats || {};
          const priorityMin =
            typeof stats.priorityMin === "number"
              ? stats.priorityMin
              : PRIORITY_CONFIG.MIN_PRIORITY;
          const priorityMax =
            typeof stats.priorityMax === "number"
              ? stats.priorityMax
              : PRIORITY_CONFIG.MAX_PRIORITY;
          const range = Math.max(1e-3, priorityMax - priorityMin);

          const timeValue =
            typeof stats.timeThreshold === "number"
              ? stats.timeThreshold
              : priorityMin + range / 2;
          const importanceValue =
            typeof stats.impThreshold === "number"
              ? stats.impThreshold
              : priorityMin + range / 2;

          const normalize = (value) =>
            Math.min(1, Math.max(0, (value - priorityMin) / range));

          const timeNorm = normalize(timeValue);
          const importanceNorm = normalize(importanceValue);

          return {
            time: Math.round((1 - timeNorm) * 100),
            importance: Math.round((1 - importanceNorm) * 100),
            timeValue,
            importanceValue,
          };
        }

        function createKanbanColumn(state) {
          const column = document.createElement("section");
          column.className = "kanban-column";
          column.dataset.state = state.id;

          const header = document.createElement("div");
          header.className = "kanban-column-header";
          const title = document.createElement("span");
          title.textContent = state.label;
          const count = document.createElement("span");
          count.className = "kanban-column-count";
          count.textContent = "0";
          header.append(title, count);

          const body = document.createElement("div");
          body.className = "kanban-column-body";
          body.dataset.state = state.id;

          const placeholder = document.createElement("p");
          placeholder.className = "kanban-column-placeholder";
          placeholder.textContent = "Nessuna attività. Trascina qui per cambiare stato.";

          setupDropZone(column, [column, body, placeholder], state.id);

          column.append(header, body);

          return {
            element: column,
            body,
            countEl: count,
            placeholder,
            count: 0,
          };
        }

        function setupDropZone(columnElement, dropTargets, stateId) {
          const targets = Array.isArray(dropTargets)
            ? dropTargets
            : [dropTargets];

          const handleDragEnter = (event) => {
            event.preventDefault();
            columnElement.classList.add("dragover");
          };

          const handleDragOver = (event) => {
            event.preventDefault();
            event.dataTransfer.dropEffect = "move";
            columnElement.classList.add("dragover");
          };

          const handleDragLeave = (event) => {
            const destination = event.relatedTarget;
            if (!destination || !columnElement.contains(destination)) {
              columnElement.classList.remove("dragover");
            }
          };

          const handleDrop = (event) => {
            event.preventDefault();
            columnElement.classList.remove("dragover");
            const payload = event.dataTransfer.getData("text/plain");
            if (!payload) return;
            let identifiers;
            try {
              identifiers = JSON.parse(payload);
            } catch (error) {
              console.warn("Payload drop non valido", error);
              return;
            }
            if (!identifiers) return;
            const ref = findTaskRef(identifiers);
            if (!ref) return;
            const nextState = stateId;
            const previous = getTaskStateId(ref.task.state);
            if (previous === nextState) return;
            if (!applyTaskStateChange(ref.task, nextState)) {
              render();
              return;
            }
            AppState.persist();
            render();
          };

          targets.forEach((target) => {
            target.addEventListener("dragenter", handleDragEnter);
            target.addEventListener("dragover", handleDragOver);
            target.addEventListener("dragleave", handleDragLeave);
            target.addEventListener("drop", handleDrop);
          });
        }

        function createKanbanCard({ role, lt, st, task }) {
          const config = getTaskStateConfig(task.state);
          const card = document.createElement("article");
          card.className = "kanban-card";
          card.draggable = true;
          card.dataset.roleId = role.id;
          card.dataset.ltId = lt.id;
          card.dataset.stId = st.id;
          card.dataset.taskId = task.id;
          card.style.borderTop = `3px solid ${config.color}`;

          card.addEventListener("dragstart", (event) => {
            event.dataTransfer.effectAllowed = "move";
            event.dataTransfer.setData(
              "text/plain",
              JSON.stringify({
                roleId: role.id,
                ltId: lt.id,
                stId: st.id,
                taskId: task.id,
              })
            );
            card.classList.add("dragging");
          });

          card.addEventListener("dragend", () => {
            card.classList.remove("dragging");
          });

          const hierarchy = document.createElement("div");
          hierarchy.className = "kanban-card-hierarchy";
          hierarchy.textContent = [role.title, lt.title, st.title]
            .map((value) => value || "—")
            .join(" › ");

          const title = document.createElement("div");
          title.className = "title";
          title.textContent = task.title || "(Senza titolo)";

          const description = document.createElement("div");
          description.className = "description";
          description.textContent = truncateText(task.description, 140);

          const importance = effectiveImportance(
            task,
            effectiveImportance(st, lt.importance)
          );
          const due = resolveTaskDueDate(lt, st, task);
          const estimate = task.estimate_hours;
          const formattedEstimate = formatHours(estimate);
          const metrics = getTaskMetrics({ role, lt, st, task }) || {};
          const meta = document.createElement("div");
          meta.className = "kanban-card-meta";
          meta.append(
            createPriorityChip(metrics),
            createQuadrantBadge(metrics.quadrant),
            createBadge(`Imp: ${importance ?? "-"}`),
            createBadge(
              `Stima: ${formattedEstimate}${
                formattedEstimate !== "-" ? " h" : ""
              }`
            ),
            createBadge(`Scadenza: ${due || "-"}`)
          );

          card.append(hierarchy, title, description, meta);
          return card;
        }

        // =============================================================
        // Factory function per creare nuovi elementi del dominio
        // =============================================================
        function createSprint(name, start, end, stGoalIds = [], id = null) {
          const sprintId = id != null ? String(id) : AppState.nextId();
          return {
            id: sprintId,
            name: name || `Sprint ${AppState.data.sprints.length + 1}`,
            start: sanitizeIsoDate(start),
            end: sanitizeIsoDate(end),
            st_goal_ids: Array.isArray(stGoalIds)
              ? stGoalIds.map((value) => String(value))
              : [],
          };
        }

        function createRole(title, importance) {
          return {
            id: AppState.nextId(),
            title,
            importance: toImportance(importance, 1),
            lt_goals: [],
          };
        }

        function createLongTerm(title, description, importance, due, achievedOn) {
          return {
            id: AppState.nextId(),
            title,
            description: description || "",
            importance: toImportance(importance, 1),
            due: due || DateUtils.today(),
            achieved_on: sanitizeIsoDate(achievedOn),
            st_goals: [],
          };
        }

        function createShortTerm(
          title,
          description,
          importance,
          due,
          { sprintId = null, achievedOn = null } = {}
        ) {
          const fallback = ensureCurrentSprintId().id;
          const targetSprintId = sprintId != null ? String(sprintId) : fallback;
          return {
            id: AppState.nextId(),
            title,
            description: description || "",
            importance: toImportanceOrNull(importance),
            due: due || null,
            achieved_on: sanitizeIsoDate(achievedOn),
            sprint_id: targetSprintId || null,
            tasks: [],
          };
        }

        function createTask(title, description, importance, due, estimateHours) {
          const task = {
            id: AppState.nextId(),
            title,
            description: description || "",
            importance: toImportanceOrNull(importance),
            due: due || null,
            state: DEFAULT_TASK_STATE,
            closed_on: null,
            estimate_hours: toHoursOrNull(estimateHours),
          };
          normalizeTask(task);
          return task;
        }

        // =============================================================
        // Export / Import CSV attività
        // =============================================================
        function exportTasksToCsv(taskRefs) {
          const lines = [TASK_CSV_HEADERS.join(",")];
          taskRefs.forEach(({ role, lt, st, task }) => {
            lines.push(
              [
                role.title || "",
                lt.title || "",
                st.title || "",
                task.title || "",
                task.description || "",
                task.importance ?? "",
                serializeHours(task.estimate_hours),
                task.due || "",
                getTaskStateId(task.state),
              ]
                .map(escapeCsvValue)
                .join(",")
            );
          });

          const blob = new Blob([lines.join("\r\n")], {
            type: "text/csv;charset=utf-8;",
          });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = TASK_CSV_FILE_NAME;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(link.href);
        }

        function escapeCsvValue(value) {
          if (value == null) return "";
          const text = String(value);
          if (/[",\n\r]/.test(text)) {
            return `"${text.replace(/"/g, '""')}"`;
          }
          return text;
        }

        function importTasksFromCsvContent(content) {
          const rows = parseCsv(content);
          if (!rows.length) {
            throw new Error("CSV vuoto");
          }

          const headerRow = rows[0];
          const indexMap = buildCsvIndexMap(headerRow);
          const missingColumns = Object.keys(TASK_CSV_COLUMN_LABELS).filter(
            (key) => indexMap[key] === -1
          );
          if (missingColumns.length) {
            const labels = missingColumns
              .map((key) => TASK_CSV_COLUMN_LABELS[key])
              .join(", ");
            throw new Error(`Colonne mancanti nel CSV: ${labels}`);
          }

          let imported = 0;
          const touchedRoles = new Set();

          for (let i = 1; i < rows.length; i += 1) {
            const row = rows[i];
            if (!row || !row.length) continue;
            const normalizedRow = headerRow.map((_, idx) => row[idx] ?? "");
            if (normalizedRow.every((value) => !value.trim())) continue;

            const roleTitle = normalizedRow[indexMap.role];
            const ltTitle = normalizedRow[indexMap.lt];
            const stTitle = normalizedRow[indexMap.st];
            const title = normalizedRow[indexMap.title] || "Attività importata";
            const description = normalizedRow[indexMap.description] || "";
            const rawImportance = normalizedRow[indexMap.importance].trim();
            let importance = null;
            if (rawImportance) {
              const parsedImportance = Number.parseInt(rawImportance, 10);
              if (!Number.isNaN(parsedImportance)) {
                importance = parsedImportance;
              }
            }
            const estimate = toHoursOrNull(normalizedRow[indexMap.estimate]);
            const due = sanitizeCsvDate(normalizedRow[indexMap.due]);
            const state = resolveTaskStateFromCsv(normalizedRow[indexMap.state]);

            const role = ensureRoleForImport(roleTitle);
            const lt = ensureLongTermForImport(role, ltTitle, due);
            const st = ensureShortTermForImport(lt, stTitle, due);

            const task = createTask(title, description, importance, due, estimate);
            task.state = state;
            normalizeTask(task);
            clampChildToParent(task, st.due ? st : lt);
            st.tasks.push(task);
            imported += 1;
            touchedRoles.add(role);
          }

          touchedRoles.forEach((role) => cascadeFromRole(role));
          if (!imported) {
            throw new Error("Nessuna attività trovata nel CSV");
          }
          return imported;
        }

        function buildCsvIndexMap(headerRow) {
          const normalized = headerRow.map(normalizeForComparison);
          const map = {};
          Object.entries(TASK_CSV_COLUMN_ALIASES).forEach(([key, aliases]) => {
            map[key] = normalized.findIndex((value) =>
              aliases.some((alias) => normalizeForComparison(alias) === value)
            );
          });
          return map;
        }

        function parseCsv(content) {
          const rows = [];
          let current = [];
          let currentValue = "";
          let inQuotes = false;

          for (let i = 0; i < content.length; i += 1) {
            const char = content[i];
            if (inQuotes) {
              if (char === '"') {
                if (content[i + 1] === '"') {
                  currentValue += '"';
                  i += 1;
                } else {
                  inQuotes = false;
                }
              } else {
                currentValue += char;
              }
              continue;
            }

            if (char === '"') {
              inQuotes = true;
            } else if (char === ',') {
              current.push(currentValue);
              currentValue = "";
            } else if (char === '\r') {
              // ignore
            } else if (char === '\n') {
              current.push(currentValue);
              rows.push(current);
              current = [];
              currentValue = "";
            } else {
              currentValue += char;
            }
          }

          current.push(currentValue);
          if (current.length > 1 || current[0] !== "") {
            rows.push(current);
          }
          return rows;
        }

        function normalizeForComparison(value) {
          return value
            ? value
                .toString()
                .trim()
                .toLowerCase()
                .normalize("NFD")
                .replace(/\p{Diacritic}/gu, "")
            : "";
        }

        function resolveTaskStateFromCsv(value) {
          const normalized = normalizeForComparison(value);
          if (!normalized) return DEFAULT_TASK_STATE;
          for (const state of TASK_STATES) {
            if (normalizeForComparison(state.id) === normalized) {
              return state.id;
            }
            if (normalizeForComparison(state.label) === normalized) {
              return state.id;
            }
          }
          return DEFAULT_TASK_STATE;
        }

        function sanitizeCsvDate(value) {
          const trimmed = (value || "").trim();
          if (!trimmed) return null;
          if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) return trimmed;
          return null;
        }

        function ensureRoleForImport(title) {
          const finalTitle = title && title.trim() ? title.trim() : "Ruolo importato";
          const normalizedTitle = normalizeForComparison(finalTitle);
          let role = AppState.data.roles.find(
            (candidate) => normalizeForComparison(candidate.title) === normalizedTitle
          );
          if (!role) {
            role = createRole(finalTitle, 3);
            AppState.data.roles.push(role);
          }
          return role;
        }

        function ensureLongTermForImport(role, title, dueHint) {
          const finalTitle = title && title.trim()
            ? title.trim()
            : "Obiettivo LT importato";
          const normalizedTitle = normalizeForComparison(finalTitle);
          let lt = role.lt_goals.find(
            (candidate) => normalizeForComparison(candidate.title) === normalizedTitle
          );
          if (!lt) {
            const due = sanitizeCsvDate(dueHint) || DateUtils.addDays(365);
            lt = createLongTerm(finalTitle, "", role.importance, due);
            clampChildToParent(lt, role);
            role.lt_goals.push(lt);
          }
          return lt;
        }

        function ensureShortTermForImport(lt, title, dueHint) {
          const finalTitle = title && title.trim()
            ? title.trim()
            : "Obiettivo BT importato";
          const normalizedTitle = normalizeForComparison(finalTitle);
          let st = lt.st_goals.find(
            (candidate) => normalizeForComparison(candidate.title) === normalizedTitle
          );
          if (!st) {
            const due = sanitizeCsvDate(dueHint) || null;
            const sprintId = ensureCurrentSprintId().id;
            st = createShortTerm(finalTitle, "", null, due, { sprintId });
            clampChildToParent(st, lt);
            lt.st_goals.push(st);
            attachShortTermToSprint(st, sprintId);
          } else if (st.sprint_id) {
            attachShortTermToSprint(st, st.sprint_id);
          }
          return st;
        }

        // =============================================================
        // Export / Import JSON
        // =============================================================
        dom.exportBtn.addEventListener("click", () => {
          const blob = new Blob([JSON.stringify(AppState.data, null, 2)], {
            type: "application/json",
          });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = DEFAULT_FILE_NAME;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(link.href);
        });

        dom.importBtn.addEventListener("click", () => dom.filePicker.click());

        dom.filePicker.addEventListener("change", async (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          try {
            const content = await file.text();
            const parsed = JSON.parse(content);
            if (!validate(parsed)) {
              alert("JSON non valido");
              return;
            }
            AppState.replace(parsed);
            render();
          } catch (error) {
            alert(`Errore import: ${error.message}`);
          } finally {
            dom.filePicker.value = "";
          }
        });

        // =============================================================
        // File System Access API
        // =============================================================
        const FileSystem = {
          supported:
            "showSaveFilePicker" in window && "showOpenFilePicker" in window,
        };

        dom.saveFileBtn.addEventListener("click", async () => {
          if (!FileSystem.supported) {
            alert(
              "Il tuo browser non supporta il salvataggio diretto. Usa Esporta JSON."
            );
            return;
          }
          try {
            if (!AppState.currentFileHandle) {
              AppState.currentFileHandle = await window.showSaveFilePicker({
                suggestedName: DEFAULT_FILE_NAME,
                types: [
                  {
                    description: "JSON",
                    accept: { "application/json": [".json"] },
                  },
                ],
              });
            }
            const writable = await AppState.currentFileHandle.createWritable();
            await writable.write(JSON.stringify(AppState.data, null, 2));
            await writable.close();
            alert("Salvato ✅");
          } catch (error) {
            if (error.name !== "AbortError") {
              alert(`Errore salvataggio: ${error.message}`);
            }
          }
        });

        dom.openFileBtn.addEventListener("click", async () => {
          if (!FileSystem.supported) {
            alert(
              "Il tuo browser non supporta l'apertura diretta. Usa Importa JSON."
            );
            return;
          }
          try {
            const [handle] = await window.showOpenFilePicker({
              types: [
                {
                  description: "JSON",
                  accept: { "application/json": [".json"] },
                },
              ],
            });
            AppState.currentFileHandle = handle;
            const file = await handle.getFile();
            const content = await file.text();
            const parsed = JSON.parse(content);
            if (!validate(parsed)) {
              alert("JSON non valido");
              return;
            }
            AppState.replace(parsed);
            render();
          } catch (error) {
            if (error.name !== "AbortError") {
              alert(`Errore apertura: ${error.message}`);
            }
          }
        });

        dom.clearBtn.addEventListener("click", () => {
          if (!confirmDelete("Sicuro di azzerare tutto?")) return;
          AppState.replace(defaultState());
          render();
        });

        // =============================================================
        // Google Drive integration (opzionale)
        // =============================================================
        function padNumber(value, length) {
          return String(value).padStart(length, "0");
        }

        function buildTimestampedDriveFileName(date = new Date()) {
          const year = date.getFullYear();
          const month = padNumber(date.getMonth() + 1, 2);
          const day = padNumber(date.getDate(), 2);
          const hours = padNumber(date.getHours(), 2);
          const minutes = padNumber(date.getMinutes(), 2);
          const seconds = padNumber(date.getSeconds(), 2);
          const millis = padNumber(date.getMilliseconds(), 3);
          return `${DRIVE_FILE_PREFIX}_${year}${month}${day}_${hours}${minutes}_${seconds}_${millis}.json`;
        }

        const GoogleDrive = {
          CLIENT_ID: localStorage.getItem(STORAGE_KEYS.GD_CLIENT_ID) || "",
          API_KEY: localStorage.getItem(STORAGE_KEYS.GD_API_KEY) || "",
          DISCOVERY_DOCS: GOOGLE_DISCOVERY_DOCS,
          SCOPES: GOOGLE_SCOPE,
          tokenClient: null,
          gapiLoaded: false,
          gisLoaded: false,
          signedIn: false,
          currentFileId: null,
          folderName: DRIVE_FOLDER_NAME,
          folderId: localStorage.getItem(STORAGE_KEYS.GD_FOLDER_ID) || null,
        };

        function updateDriveUI() {
          dom.driveStatus.textContent = GoogleDrive.signedIn
            ? "Drive: connesso"
            : "Drive: offline";
          dom.driveOpenBtn.disabled = !GoogleDrive.signedIn;
          dom.driveSaveBtn.disabled = !GoogleDrive.signedIn;
        }

        function saveDriveCredentials() {
          localStorage.setItem(STORAGE_KEYS.GD_CLIENT_ID, GoogleDrive.CLIENT_ID);
          localStorage.setItem(STORAGE_KEYS.GD_API_KEY, GoogleDrive.API_KEY);
        }

        function persistDriveFolderId(id) {
          GoogleDrive.folderId = id || null;
          if (GoogleDrive.folderId) {
            localStorage.setItem(STORAGE_KEYS.GD_FOLDER_ID, GoogleDrive.folderId);
          } else {
            localStorage.removeItem(STORAGE_KEYS.GD_FOLDER_ID);
          }
        }

        function askForDriveCredentials() {
          const clientId = prompt(
            "Inserisci il tuo Google OAuth CLIENT_ID (tipo ...apps.googleusercontent.com):",
            GoogleDrive.CLIENT_ID || ""
          );
          if (!clientId) return false;
          const apiKey = prompt(
            "Inserisci la tua Google API KEY:",
            GoogleDrive.API_KEY || ""
          );
          if (!apiKey) return false;
          GoogleDrive.CLIENT_ID = clientId.trim();
          GoogleDrive.API_KEY = apiKey.trim();
          saveDriveCredentials();
          return true;
        }

        function loadGapi() {
          return new Promise((resolve, reject) => {
            if (GoogleDrive.gapiLoaded) {
              resolve();
              return;
            }
            const script = document.createElement("script");
            script.src = "https://apis.google.com/js/api.js";
            script.onload = () => {
              gapi.load("client", async () => {
                try {
                  await gapi.client.init({
                    apiKey: GoogleDrive.API_KEY,
                    discoveryDocs: GoogleDrive.DISCOVERY_DOCS,
                  });
                  GoogleDrive.gapiLoaded = true;
                  resolve();
                } catch (error) {
                  reject(error);
                }
              });
            };
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        function loadGoogleIdentityServices() {
          return new Promise((resolve, reject) => {
            if (GoogleDrive.gisLoaded) {
              resolve();
              return;
            }
            const script = document.createElement("script");
            script.src = "https://accounts.google.com/gsi/client";
            script.onload = () => {
              try {
                GoogleDrive.tokenClient = google.accounts.oauth2.initTokenClient({
                  client_id: GoogleDrive.CLIENT_ID,
                  scope: GoogleDrive.SCOPES,
                  callback: (response) => {
                    if (response && response.access_token) {
                      GoogleDrive.signedIn = true;
                      updateDriveUI();
                    }
                  },
                });
                GoogleDrive.gisLoaded = true;
                resolve();
              } catch (error) {
                reject(error);
              }
            };
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        async function ensureDriveReady() {
         // if (location.protocol === "file:") {
         //   alert(
         //     "Per usare Google Drive apri la pagina da http://localhost o https://"
         //   );
         //   return false;
         // }
          if (!GoogleDrive.CLIENT_ID || !GoogleDrive.API_KEY) {
            const ok = askForDriveCredentials();
            if (!ok) return false;
          }
          try {
            await loadGoogleIdentityServices();
          } catch (error) {
            alert(`Errore GIS: ${error.message || error}`);
            return false;
          }
          try {
            await loadGapi();
          } catch (error) {
            console.warn("Uso fallback REST (senza discovery):", error);
          }
          return true;
        }

        async function ensureDriveFolder() {
          if (GoogleDrive.folderId) return GoogleDrive.folderId;
          const folderName = GoogleDrive.folderName;
          const query =
            "mimeType='application/vnd.google-apps.folder' and trashed=false and name='" +
            folderName +
            "'";
          const findWithGapi = async () => {
            if (!(GoogleDrive.gapiLoaded && window.gapi?.client?.drive)) return null;
            try {
              const response = await gapi.client.drive.files.list({
                q: query,
                fields: "files(id,name)",
                pageSize: 1,
              });
              return response.result.files?.[0] || null;
            } catch (error) {
              console.warn("Ricerca cartella via gapi fallita, provo fallback:", error);
              return null;
            }
          };

          const findWithRest = async () => {
            try {
              const response = await driveFetch("files", {
                q: query,
                fields: "files(id,name)",
                pageSize: "1",
              });
              return response.files?.[0] || null;
            } catch (error) {
              console.warn("Ricerca cartella via REST fallita:", error);
              return null;
            }
          };

          const createWithGapi = async () => {
            if (!(GoogleDrive.gapiLoaded && window.gapi?.client?.drive)) return null;
            try {
              const response = await gapi.client.drive.files.create({
                resource: {
                  name: folderName,
                  mimeType: "application/vnd.google-apps.folder",
                },
                fields: "id",
              });
              return { id: response.result?.id };
            } catch (error) {
              console.warn("Creazione cartella via gapi fallita, provo REST:", error);
              return null;
            }
          };

          const createWithRest = async () => {
            const response = await driveFetch(
              "files",
              { fields: "id" },
              "POST",
              {
                name: folderName,
                mimeType: "application/vnd.google-apps.folder",
              }
            );
            return { id: response.id };
          };

          let folder = (await findWithGapi()) || (await findWithRest());
          if (!folder) {
            folder = (await createWithGapi()) || (await createWithRest());
          }
          if (!folder?.id) {
            throw new Error(
              "Impossibile accedere o creare la cartella Kanban_Covey_BigRocks su Drive"
            );
          }
          persistDriveFolderId(folder.id);
          return folder.id;
        }

        async function driveFetch(path, params = {}, method = "GET", body = null) {
          const tokenObj = google.accounts.oauth2.getToken?.();
          const token = tokenObj && tokenObj.access_token;
          if (!token) throw new Error('Nessun access token disponibile. Premi "Connetti Google".');
          const url = new URL(`https://www.googleapis.com/drive/v3/${path}`);
          Object.entries(params).forEach(([key, value]) =>
            url.searchParams.set(key, value)
          );
          const response = await fetch(url.toString(), {
            method,
            headers: {
              Authorization: `Bearer ${token}`,
              ...(body ? { "Content-Type": "application/json" } : {}),
            },
            body: body ? JSON.stringify(body) : null,
          });
          if (!response.ok) {
            throw new Error(`Drive REST error ${response.status}: ${await response.text()}`);
          }
          return response.json();
        }

        async function listJsonFilesFallback(folderId) {
          const q = `'${folderId}' in parents and mimeType='application/json' and trashed=false`;
          return driveFetch("files", {
            q,
            fields: "files(id,name,modifiedTime)",
            pageSize: "25",
          });
        }

        async function getFileContentFallback(fileId) {
          const tokenObj = google.accounts.oauth2.getToken?.();
          const token = tokenObj && tokenObj.access_token;
          const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(
            fileId
          )}?alt=media`;
          const response = await fetch(url, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });
          if (!response.ok) {
            throw new Error(`Download error ${response.status}`);
          }
          return response.text();
        }

        async function uploadJsonFallback(name, content, folderId) {
          const boundary = "-------314159265358979323846";
          const delimiter = `\r\n--${boundary}\r\n`;
          const closeDelimiter = `\r\n--${boundary}--`;
          const metadata = {
            name,
            mimeType: "application/json",
            parents: [folderId],
          };
          const multipartBody =
            `${delimiter}Content-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(metadata)}` +
            `${delimiter}Content-Type: application/json\r\n\r\n${content}${closeDelimiter}`;

          const tokenObj = google.accounts.oauth2.getToken?.();
          const token = tokenObj && tokenObj.access_token;
          const response = await fetch(
            "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",
            {
              method: "POST",
              headers: {
                Authorization: `Bearer ${token}`,
                "Content-Type": `multipart/related; boundary=${boundary}`,
              },
              body: multipartBody,
            }
          );
          if (!response.ok) {
            throw new Error(`Upload error ${response.status}: ${await response.text()}`);
          }
          const json = await response.json();
          return json.id;
        }

        dom.googleBtn.addEventListener("click", async () => {
          if (!(await ensureDriveReady())) return;
          try {
            GoogleDrive.tokenClient.requestAccessToken({ prompt: "consent" });
          } catch (error) {
            alert(`Autorizzazione Google fallita: ${error.message || error}`);
          }
        });

        dom.driveOpenBtn.addEventListener("click", async () => {
          try {
            if (!(await ensureDriveReady())) return;
            const folderId = await ensureDriveFolder();
            let files = [];
            if (GoogleDrive.gapiLoaded && window.gapi?.client?.drive) {
              try {
                const response = await gapi.client.drive.files.list({
                  q: `'${folderId}' in parents and mimeType='application/json' and trashed=false`,
                  pageSize: 25,
                  fields: "files(id,name,modifiedTime)",
                });
                files = response.result.files || [];
              } catch (error) {
                console.warn("gapi list fallita, passo a REST fallback:", error);
              }
            }
            if (!files.length) {
              const response = await listJsonFilesFallback(folderId);
              files = response.files || [];
            }
            if (!files.length) {
              alert("Nessun JSON trovato nel tuo Drive.");
              return;
            }
            const nameList = files
              .map(
                (file, index) =>
                  `${index + 1}) ${file.name} — ${new Date(
                    file.modifiedTime
                  ).toLocaleString()}`
              )
              .join("\n");
            const idx = prompt(`Scegli file da aprire (numero):\n${nameList}`);
            const selectedIndex = Number(idx) - 1;
            if (!(selectedIndex >= 0 && selectedIndex < files.length)) return;
            const file = files[selectedIndex];
            let text;
            if (GoogleDrive.gapiLoaded && window.gapi?.client?.drive) {
              try {
                const download = await gapi.client.drive.files.get({
                  fileId: file.id,
                  alt: "media",
                });
                text = download.body;
              } catch (error) {
                console.warn("gapi download fallito, uso REST:", error);
                text = await getFileContentFallback(file.id);
              }
            } else {
              text = await getFileContentFallback(file.id);
            }
            const data = JSON.parse(text);
            if (!validate(data)) {
              alert("JSON non valido");
              return;
            }
            AppState.replace(data);
            GoogleDrive.currentFileId = file.id;
            alert(`Aperto da Drive: ${file.name}`);
            render();
          } catch (error) {
            alert(`Errore apertura Drive: ${error.message || error}`);
          }
        });

        dom.driveSaveBtn.addEventListener("click", async () => {
          try {
            if (!(await ensureDriveReady())) return;
            const folderId = await ensureDriveFolder();
            const fileName = buildTimestampedDriveFileName();
            const content = JSON.stringify(AppState.data, null, 2);
            if (GoogleDrive.gapiLoaded && window.gapi?.client?.drive) {
              try {
                const boundary = "-------314159265358979323846";
                const delimiter = `\r\n--${boundary}\r\n`;
                const closeDelimiter = `\r\n--${boundary}--`;
                const metadata = {
                  name: fileName,
                  mimeType: "application/json",
                  parents: [folderId],
                };
                const multipartBody =
                  `${delimiter}Content-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(metadata)}` +
                  `${delimiter}Content-Type: application/json\r\n\r\n${content}${closeDelimiter}`;

                const response = await gapi.client.request({
                  path: "/upload/drive/v3/files",
                  method: "POST",
                  params: { uploadType: "multipart" },
                  headers: {
                    "Content-Type": `multipart/related; boundary=${boundary}`,
                  },
                  body: multipartBody,
                });
                GoogleDrive.currentFileId = response.result?.id || null;
                alert("Salvato su Drive ✅");
                return;
              } catch (error) {
                console.warn("gapi upload fallito, uso REST:", error);
              }
            }
            GoogleDrive.currentFileId = await uploadJsonFallback(
              fileName,
              content,
              folderId
            );
            alert("Salvato su Drive (REST) ✅");
          } catch (error) {
            alert(`Errore salvataggio Drive: ${error.message || error}`);
          }
        });

        updateDriveUI();
        render();
      })();
    </script>
  </body>
</html>
